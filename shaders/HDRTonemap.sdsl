// ============================================================================
// HDRTonemap.sdsl
// Base mixin: tonemapping + output transform utility methods
// ============================================================================
//
// Provides the tonemap+output pipeline used by both:
// - HDRTonemap_TextureFX (standalone tonemap)
// - HDRGrade_Tonemap_TextureFX (combined grade + tonemap)
//
// No pin declarations — all parameters are passed to the utility method.
// Each consumer declares its own pins (avoiding name conflicts).
//
// Operators:
//  0 - None (passthrough)
//  1 - ACES (Fit) - Stephen Hill approximation with AP1 gamut mapping
//  2 - ACES 1.3 - Full RRT + ODT (segmented spline tone curves)
//  3 - ACES 2.0 - Daniele Evo tonescale (simplified, no Hellwig CAM)
//  4 - AgX - Troy Sobotka, exact analytical curve (Blender default)
//  5 - Gran Turismo - Uchimura (HDR-aware parametric curve)
//  6 - Uncharted 2 - Filmic curve (John Hable)
//  7 - Khronos PBR Neutral - E-commerce/product visualization
//  8 - Lottes - Luma-based (Epic Games)
//  9 - Reinhard - Simple Reinhard
// 10 - Reinhard Extended - Adjustable white point
// 11 - Hejl-Burgess - Fast approximation
//
// ============================================================================

shader HDRTonemap : TonemapOperators
{
    // ========================================================================
    // UTILITY METHOD
    // ========================================================================

    // Full tonemap + output transform pipeline.
    // Takes any input color space, applies tonemap, converts to output space.
    // Does NOT apply display range remap — caller applies RemapDisplayRange() at the end.
    float3 ApplyTonemapOutput(float3 color, int inputSpace, int outputSpace,
                              int tonemap, float exposure, float whitePoint,
                              float paperWhite, float peakBrightness)
    {
        // ----------------------------------------------------------------
        // ACES 1.3 / 2.0: full RRT+ODT with output-space-dependent ODT
        // These need ACEScg input and choose ODT variant based on output target.
        // ----------------------------------------------------------------
        if (tonemap == 2 || tonemap == 3)
        {
            // Convert input to ACEScg (AP1) with direct paths for common cases
            float3 acescg;
            if (inputSpace == 2)        // ACEScg — passthrough
                acescg = color;
            else if (inputSpace == 0)   // Linear Rec.709
                acescg = mul(Rec709_to_AP1, color);
            else if (inputSpace == 1)   // Linear Rec.2020
                acescg = mul(Rec2020_to_AP1, color);
            else if (inputSpace == 4)   // ACEScct
                acescg = ACEScctToLinear(color);
            else if (inputSpace == 3)   // ACEScc
                acescg = ACESccToLinear(color);
            else                        // sRGB, PQ, HLG, scRGB → hub → AP1
                acescg = mul(Rec709_to_AP1, ToLinearRec709(color, inputSpace));

            // Apply exposure in scene-linear AP1
            acescg *= exp2(exposure);

            // Choose ODT based on output gamut target
            // Rec.2020 targets (Linear2020=1, PQ=6, HLG=7) use Rec.2020 ODT
            // Everything else uses Rec.709 ODT
            bool isRec2020Target = (outputSpace == 1 || outputSpace == 6 || outputSpace == 7);
            float3 displayLinear;
            float peakNits;

            if (tonemap == 2) // ACES 1.3
            {
                float3 rrt = ACES13_RRT(acescg);
                if (isRec2020Target)
                {
                    displayLinear = ACES13_ODT_Rec2020_1000nits(rrt);
                    peakNits = 1000.0;
                }
                else
                {
                    displayLinear = ACES13_ODT_Rec709_100nits(rrt);
                    peakNits = 100.0;
                }
            }
            else // ACES 2.0
            {
                if (isRec2020Target)
                    displayLinear = ACES20_OutputTransform_Rec2020_Nits(acescg, peakBrightness);
                else
                    displayLinear = ACES20_OutputTransform_Rec709_Nits(acescg, peakBrightness);
                peakNits = peakBrightness;
            }

            // Apply OETF / output encoding
            // displayLinear is already in the correct gamut (709 or 2020)
            if (outputSpace == 5)       // sRGB
                return LinearToSRGB(saturate(displayLinear));
            else if (outputSpace == 6)  // PQ Rec.2020
                return LinearToPQ(clamp(displayLinear * peakNits / PQ_MAX_NITS, 0.0, 1.0));
            else if (outputSpace == 7)  // HLG Rec.2020
                return LinearToHLG(clamp(displayLinear, 0.0, 1.0));
            else if (outputSpace == 8)  // scRGB
                return displayLinear * (peakNits / 80.0);
            else                        // Linear Rec.709 (0), Linear Rec.2020 (1), ACEScg (2), etc.
                return displayLinear;
        }

        // ----------------------------------------------------------------
        // All other operators (0, 1, 4-11): existing path via ApplyTonemap
        // ----------------------------------------------------------------
        float3 linear709 = ApplyTonemap(color, inputSpace, tonemap, exposure, whitePoint);

        // Convert to output color space
        // HDR outputs handle gamut + PaperWhite + transfer function directly
        if (outputSpace == 6)       // PQ Rec.2020
        {
            float3 rec2020 = mul(Rec709_to_Rec2020, linear709);
            return LinearToPQ(rec2020 * paperWhite / PQ_MAX_NITS);
        }
        else if (outputSpace == 7)  // HLG Rec.2020
        {
            float3 rec2020 = mul(Rec709_to_Rec2020, linear709);
            float peak = max(peakBrightness, 1.0);
            return LinearToHLG(clamp(rec2020 * paperWhite / peak, 0.0, 1.0));
        }
        else if (outputSpace == 8)  // scRGB
        {
            return linear709 * (paperWhite / 80.0);
        }
        else                        // Non-HDR outputs (0-5): use standard conversion
        {
            return FromLinearRec709(linear709, outputSpace);
        }
    }

    // Display range remap: map [0,1] to [blackLevel, whiteLevel].
    // Compensates for display hardware (projectors, LED walls).
    // Apply as the very last step before output.
    float3 RemapDisplayRange(float3 color, float blackLevel, float whiteLevel)
    {
        return blackLevel + color * (whiteLevel - blackLevel);
    }
};
