### Iteration 1 — 2026-02-21 — 1.1: Initialize Vite + React 19 + TypeScript + Tailwind 4 project
- Implemented: Created pipeline-checker/ with package.json (React 19, Three.js, Vite 6, Tailwind 4, vite-plugin-singlefile), vite.config.ts (base ./, asset inlining, single-file build), tsconfig.json + tsconfig.node.json, index.html with dark BG flash prevention, src/index.css (Tailwind v4 @import + dark theme CSS vars), src/main.tsx, src/App.tsx (minimal placeholder), type declarations for .wgsl?raw and .exr imports, and webgpu.d.ts reference.
- Files changed: pipeline-checker/package.json, vite.config.ts, tsconfig.json, tsconfig.node.json, index.html, src/index.css, src/main.tsx, src/App.tsx, src/types/raw-imports.d.ts, src/types/webgpu.d.ts
- Learnings: Tailwind v4 uses @tailwindcss/vite plugin instead of postcss.config.js. No tailwind.config.js needed. App.tsx is a minimal placeholder — WebGPUContext and DropZone are separate tasks (1.2, 1.3).
- Validation: npm install (0 vulnerabilities), npx tsc --noEmit (clean), npm run build (200 KB single HTML)

### Iteration 2 — 2026-02-21 — 1.2: WebGPU device initialization
- Implemented: Created src/gpu/WebGPUContext.ts with GPUContext interface (adapter, device, format, canvasContext, hasBC), initWebGPU() async function that requests high-performance adapter, conditionally enables texture-compression-bc, sets 256MB storage/buffer limits, configures canvas with premultiplied alpha, and handles device.lost.
- Files changed: pipeline-checker/src/gpu/WebGPUContext.ts
- Learnings: Extended GPUContext interface beyond spec template to include canvasContext and hasBC flag for downstream use. device.lost handler logs but doesn't auto-recover yet.
- Validation: npx tsc --noEmit (clean), npm run build (201 KB single HTML)

### Iteration 3 — 2026-02-21 — 1.3: EXR drop zone component + Try sample button
- Implemented: Created DropZone.tsx with drag-drop EXR support (Three.js EXRLoader, half-float conversion), procedural HDR sample generator (256x256 hue/brightness gradient), drag counter pattern for flicker prevention. Created WebGPUCanvas.tsx (hidden 1x1 canvas for WebGPU context). Updated App.tsx with state machine (initializing/error/ready/loaded), WebGPU init on mount, DropZone integration.
- Files changed: pipeline-checker/src/components/DropZone.tsx (new), pipeline-checker/src/components/WebGPUCanvas.tsx (new), pipeline-checker/src/App.tsx (rewritten)
- Learnings: Used procedural sample generation instead of importing a .exr asset file — avoids build dependency on a binary asset. Task 1.5 in phase file was merged into 1.3 in fix_plan.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML)

### Iteration 4 — 2026-02-21 — 1.4: Dark theme setup
- Implemented: Verified dark theme was already complete from iteration 1. All CSS custom properties match spec exactly: --color-bg #0d0d0d, --color-surface #1a1a1a, --color-border #2a2a2a, --color-text #e0e0e0, --color-text-muted #808080, --color-accent #4a4a4a, --color-accent-hover #5a5a5a, --color-error #cc4444. No saturated accent colors anywhere. White-flash prevention inline style in index.html. Scrollbar theming.
- Files changed: None (theme was already correct; only checkboxes updated)
- Learnings: Task 1.4 was effectively completed during 1.1 when index.css was created. All components already use CSS vars, no hardcoded saturated colors.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML), grep confirmed no saturated color literals in src/

### Iteration 5 — 2026-02-21 — 1.5: Phase 1 final verification
- Implemented: Ran all three verification commands. npm install (0 vulnerabilities, 98 packages), npx tsc --noEmit (clean), npm run build (296 KB single HTML). Phase 1 is fully complete.
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 1 complete. Wave 1 done. Next is Wave 2: Phase 3 (WebGPU Render Pipeline) or Phase 5 (BC Encoder). Phase 3 should come first since Phase 4 depends on it.
- Validation: npm install (clean), npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 6 — 2026-02-21 — 3.1: PipelineStage interface
- Implemented: Created src/pipeline/PipelineStage.ts with the PipelineStage interface — name, index, enabled, output properties + initialize/resize/encode/destroy lifecycle methods. encode() takes GPUCommandEncoder, GPUTexture (input), GPUBuffer (uniforms).
- Files changed: pipeline-checker/src/pipeline/PipelineStage.ts (new)
- Learnings: Section file clarifies encode() takes GPUBuffer (not PipelineSettings type), keeping the interface dependency-free. PipelineSettings type comes in task 3.5.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 7 — 2026-02-21 — 3.2: FragmentStage implementation
- Implemented: Created src/pipeline/FragmentStage.ts implementing PipelineStage. Includes embedded fullscreen triangle vertex shader (no external file), bind group layout (unfilterable-float texture + non-filtering sampler + uniform buffer), GPURenderPipeline creation with rgba32float target (blend: undefined), encode() with per-frame bind group, render target with RENDER_ATTACHMENT | TEXTURE_BINDING | COPY_SRC. Constructor takes (name, index, fragmentWGSL) — vertex shader is prepended automatically.
- Files changed: pipeline-checker/src/pipeline/FragmentStage.ts (new)
- Learnings: tsconfig has noUnusedLocals — removed width/height private fields that were stored but never read. The vertex shader is embedded as a string constant per section-03 spec ("embedded as a constant string in FragmentStage.ts"). The fullscreen-quad.wgsl file (task 4.7) can refactor this later if needed.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 8 — 2026-02-21 — 3.3: PipelineRenderer orchestrator
- Implemented: Created src/pipeline/PipelineRenderer.ts — stage orchestrator with: constructor creates 512-byte uniform buffer, setStages() registers stages, setSize() initializes (first call) or resizes (subsequent) all stages, render() chains enabled stages in single command buffer (disabled stages bypass transparently), getStageOutput() walks backwards to find last enabled stage, updateUniforms() writes raw Float32Array to GPU buffer, destroy() cleans up all resources.
- Files changed: pipeline-checker/src/pipeline/PipelineRenderer.ts (new)
- Learnings: WebGPU TypeScript types require Float32Array<ArrayBuffer> (not Float32Array<ArrayBufferLike>) for writeBuffer compatibility. Fixed spec's setSize bug where this.width was set before the initialization check. The PipelineSettings typed interface comes in 3.5 — for now updateUniforms takes raw Float32Array.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 9 — 2026-02-21 — 3.4: Render target management
- Implemented: Created src/pipeline/TextureUtils.ts with shared utilities: BYTES_PER_PIXEL (16) and ROW_ALIGNMENT (256) constants, alignedBytesPerRow() for 256-byte readback alignment, copyAlignedToContiguous() for stripping row padding from mapped buffers, uploadFloat32Texture() for writing Float32Array RGBA data to GPUTexture (TEXTURE_BINDING | COPY_SRC | COPY_DST). Render target creation itself was already in FragmentStage (RENDER_ATTACHMENT | TEXTURE_BINDING | COPY_SRC).
- Files changed: pipeline-checker/src/pipeline/TextureUtils.ts (new)
- Learnings: writeTexture (upload) does NOT require 256-byte bytesPerRow alignment — only copyTextureToBuffer (readback) does. Upload uses width*16 directly. The upload texture needs COPY_DST (for upload) while stage render targets don't (they write via render passes).
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 10 — 2026-02-21 — 3.5: PipelineUniforms
- Implemented: Created src/pipeline/PipelineUniforms.ts with: PipelineSettings interface (all 30+ fields covering stages 4-9 + toggles + BC + view), DEFAULT_SETTINGS constant (neutral grading, no tonemap, passthrough), serializeUniforms() that writes to a shared Float32Array/Int32Array (512 bytes). Layout matches WGSL struct with vec3+pad pattern: 10 scalars, 2-float pad, 7x vec3+pad blocks, 4 more scalars, 6 tonemap fields, 2 remap fields, 3 toggle i32s, 2 BC i32s, 1 view float. Total ~232 bytes used of 512.
- Files changed: pipeline-checker/src/pipeline/PipelineUniforms.ts (new)
- Learnings: serializeUniforms returns Float32Array<ArrayBuffer> (matching PipelineRenderer.updateUniforms signature). The _pad0 at offset 40 is vec2<f32> (8 bytes) to align the first vec3 (lift) to 16-byte boundary at offset 48. All subsequent vec3s naturally align because each is 12+4=16 bytes.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 11 — 2026-02-21 — 3.6: PixelReadback utility
- Implemented: Created src/pipeline/PixelReadback.ts with async readPixel(texture, x, y) method. Uses pending flag for debounce (returns null if previous read in-flight). Creates 256-byte staging buffer per read (minimum for bytesPerRow alignment), copyTextureToBuffer for single pixel, mapAsync + getMappedRange to extract [R,G,B,A] Float32Array(4). Buffer destroyed after each read.
- Files changed: pipeline-checker/src/pipeline/PixelReadback.ts (new)
- Learnings: Even single-pixel readback requires 256-byte bytesPerRow alignment. Throttling to 30Hz is handled by the caller (Phase 8 UI), not by this class. try/finally ensures pending flag is always reset even on error.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 12 — 2026-02-21 — 3.7: Phase 3 final verification
- Implemented: Ran full verification suite. All 6 pipeline files present: PipelineStage.ts, FragmentStage.ts, PipelineRenderer.ts, TextureUtils.ts, PipelineUniforms.ts, PixelReadback.ts. npm install (0 vulnerabilities), npx tsc --noEmit (clean), npm run build (296 KB single HTML). Phase 3 is fully complete.
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 3 complete. Wave 2 Phase 3 done. Next is either Phase 5 (BC Encoder Package) or skip to Wave 3 Phase 4 (Color Pipeline WGSL Shaders) — but Phase 4 requires Phase 3 which is now done. Phase 5 (BC) is optional per dependency rules. Follow fix_plan.md order: Phase 5 next.
- Validation: npm install (clean), npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 13 — 2026-02-21 — 5.1: BC encoder package scaffolding
- Implemented: Created packages/webgpu-bc-encoder/ with package.json, tsconfig.json, and all source files: index.ts (types + constants), encoder.ts (BCEncoder placeholder), metrics.ts (BCMetricsComputer placeholder), formats/handler.ts (BCFormatHandler interface), 7 format handler files (bc1-bc7.ts), 8 WGSL compute shader placeholders, wgsl.d.ts type declaration.
- Files changed: 24 files in packages/webgpu-bc-encoder/
- Learnings: Package needs its own wgsl.d.ts for ?raw import type resolution. Format handlers use placeholder throw for task 5.2 implementation.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 14 — 2026-02-21 — 5.2 + 5.3: Port WGSL compute shaders + BCEncoder class
- Implemented: Wrote all 7 BC format WGSL compute shaders with real encoding algorithms:
  - BC1: bounding box min/max endpoints, RGB565 packing, 4-color palette, 2-bit indices
  - BC4: min/max single channel, u8 endpoints, 8-value interpolation, 3-bit indices
  - BC2: BC1 color + 4-bit explicit alpha per pixel
  - BC3: BC1 color + BC4-style interpolated alpha
  - BC5: Two independent BC4 blocks (R + G channels)
  - BC6H: Mode 11 (unsigned, no partitioning, 10-bit endpoints, 4-bit indices, pack2x16float)
  - BC7: Mode 6 (no partitioning, RGBA 7+1 bit endpoints, 4-bit indices)
  Updated all format handlers to import WGSL via ?raw and create real GPUComputePipeline.
  Rewrote encoder.ts with full pipeline: getPipeline cache, uniform buffer, storage buffer, bind group, dispatch, staging readback.
  Added BCFormatHandler.supportsAlpha + alphaWarning fields. BC6H has alphaWarning string.
  Added static BCEncoder.getHandler() for downstream alpha warning access.
- Files changed: 7 WGSL shaders, 8 format .ts files (handler + bc1-bc7), encoder.ts, index.ts, wgsl.d.ts
- Learnings: block_compression repo not accessible (404). Implemented from BC spec knowledge. BC6H Mode 11 uses pack2x16float for float-to-half conversion. Anchor index fix: if anchor pixel >= half, flip all indices. All shaders share common bind group layout (binding 0=texture, 1=storage, 2=uniform). Task 5.3 was naturally completed alongside 5.2 since the encoder needed the pipelines.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 15 — 2026-02-21 — 5.4: BC metrics compute shader
- Implemented: Wrote bc-metrics.wgsl compute shader (8x8 workgroups) that computes per-pixel squared error and absolute error (6 floats per pixel: SE_R, SE_G, SE_B, AE_R, AE_G, AE_B). Implemented BCMetricsComputer class in metrics.ts with: lazy pipeline creation, GPU dispatch, staging buffer readback, CPU-side reduction (sum SE → MSE, max AE → max error), PSNR computation (10*log10(1/MSE)). Added mseCombined field to BCMetrics interface in index.ts.
- Files changed: packages/webgpu-bc-encoder/src/shaders/bc-metrics.wgsl, packages/webgpu-bc-encoder/src/metrics.ts, packages/webgpu-bc-encoder/src/index.ts
- Learnings: Uniform buffer for metrics params only needs 8 bytes (2 x u32). Error buffer is width*height*6*4 bytes — can be large for high-res images. CPU reduction is simple enough that GPU reduction isn't needed for interactive use.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 16 — 2026-02-21 — 5.5: Phase 5 verification
- Implemented: Verification pass — no code changes needed. Confirmed: tsc --noEmit clean, npm run build clean (296 KB), all 8 WGSL shaders present (7 encode + 1 metrics), all 7 format handlers + handler interface present, all exports correct (BCEncoder, BCMetricsComputer, BCFormatHandler, BCFormat, BCQuality, BCEncodeResult, BCMetrics, BC_BLOCK_SIZE, BC_FORMAT_TO_GPU), all shader imports use ?raw (no fetch), BC6H alpha warning correctly configured (supportsAlpha: false, alphaWarning populated).
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 5 complete. Wave 2 fully done. Next is Wave 3: Phase 4 (Color Pipeline WGSL Shaders) — requires reading phase-04-color-shaders.md and its section file for tonemap algorithm constants.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 17 — 2026-02-21 — 4.1: input-convert.wgsl (Stage 4 — Input Interpretation)
- Implemented: Created src/shaders/generated/input-convert.wgsl with complete color space conversion library. All 6 gamut matrices transposed for WGSL column-major (Rec709↔Rec2020, Rec709↔AP1, Rec2020↔AP1). All 10 transfer functions (sRGB IEC 61966-2-1 piecewise, ACEScc branchless log2, ACEScct branchless with step(), PQ ST.2084, HLG ARIB STD-B67 branchless). ToLinearRec709() + FromLinearRec709() + ConvertColorSpace() hub functions. Fragment shader reads inputSpace uniform (i32 at offset 0) and converts input to Linear Rec.709. Vertex shader is prepended by FragmentStage — shader only declares bindings 0/1/2 and fs entrypoint.
- Files changed: pipeline-checker/src/shaders/generated/input-convert.wgsl (new)
- Learnings: FragmentStage prepends VertexOutput struct + vs entrypoint. Fragment shader must NOT redeclare these. Uniform struct can be minimal — only declare fields this stage reads (inputSpace at offset 0). WGSL step() takes vec3 args when operating on vec3 (e.g., step(vec3<f32>(0.5), V) not step(0.5, V)).
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 18 — 2026-02-21 — 4.2: color-grade.wgsl (Stage 5 — Color Grading)
- Implemented: Created src/shaders/generated/color-grade.wgsl with full professional color grading. Uniform struct covers PipelineUniforms offsets 0-172 (22 params: inputSpace, gradingSpace, exposure, contrast, saturation, temperature, tint, highlights, shadows, vibrance, lift/gamma/gain/offset vec3, shadowColor/midtoneColor/highlightColor vec3, highlightSoftClip/shadowSoftClip/highlightKnee/shadowKnee). WGSL vec3 alignment causes implicit 8-byte padding between vibrance (offset 36) and lift (offset 48) — matches PipelineUniforms.ts layout. Includes DecodeInput() (any space → Linear AP1 via hub), ApplyGradingLog() (12-step ACEScct workflow), ApplyGradingLinear() (11-step ACEScg workflow), GetZoneWeights(), ApplySoftClip(). Output converts back via AP1_to_Rec709.
- Files changed: pipeline-checker/src/shaders/generated/color-grade.wgsl (new)
- Learnings: WGSL `step(scalar, vec3)` doesn't auto-broadcast — use `step(vec3<f32>(scalar), vec3)` for vec3 comparisons. In ApplySoftClip, the `step(0.001, hStr)` is scalar×scalar producing scalar, which then multiplies vec3 — this works in WGSL. The `offset` WGSL keyword issue was avoided by naming the field `offset_val`. WGSL pow() requires vec3 args for vec3 results: `pow(vec3, vec3<f32>(scalar))`.
- Validation: npx tsc --noEmit (clean), npm run build (298 KB)

### Iteration 19 — 2026-02-21 — 4.8: Wire all stages into PipelineRenderer
- Implemented: Created 6 stage wrapper files in src/pipeline/stages/ (InputConvertStage.ts, ColorGradeStage.ts, RRTStage.ts, ODTStage.ts, OutputEncodeStage.ts, DisplayRemapStage.ts). Each is a factory function that imports the WGSL shader via ?raw and returns a FragmentStage instance. Created index.ts barrel with createColorPipelineStages() that returns all 6 stages in order (Stages 4-9). Also includes 4.6 (display-remap.wgsl) and 4.7 (fullscreen-vert.wgsl extraction from FragmentStage.ts inline to ?raw import).
- Files changed: pipeline-checker/src/pipeline/stages/{InputConvertStage,ColorGradeStage,RRTStage,ODTStage,OutputEncodeStage,DisplayRemapStage,index}.ts (new), pipeline-checker/src/shaders/generated/{display-remap,fullscreen-vert}.wgsl (new), pipeline-checker/src/pipeline/FragmentStage.ts (refactored inline vertex to ?raw import)
- Learnings: Stage files are tree-shaken until a consumer (usePipeline hook or App) imports createColorPipelineStages(). The 38-module count stays stable because Vite only includes reachable modules.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 20 — 2026-02-21 — 4.9: Phase 4 verification gate
- Implemented: Verified all Phase 4 deliverables. tsc --noEmit clean, npm run build 297.86 KB. All 7 WGSL files present (6 fragment shaders + 1 vertex shader). All 6 fragment shaders have @fragment fn fs entry point and @group(0) @binding(2) uniform binding. fullscreen-vert.wgsl has @vertex fn vs. 6 stage factory files create correct stage indices (4-9) with descriptive names. Barrel index.ts creates stages in correct pipeline order. FragmentStage.ts imports fullscreen-vert.wgsl via ?raw (no inline duplication). Phase 4 complete.
- Files changed: .ralph/fix_plan.md, .ralph/specs/phase-04-color-shaders.md (checkboxes only)
- Learnings: Visual EXR test requires browser+WebGPU — deferred to manual testing. All static verification passes. Phase 4 is the completion gate for all 6 color pipeline shaders.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB), all WGSL files verified

### Iteration 21 — 2026-02-21 — 6.1: BCCompressStage compute stage
- Implemented: Created src/pipeline/stages/BCCompressStage.ts implementing PipelineStage interface. Compute stage (not fragment) that wraps the @vl-ocio/webgpu-bc-encoder BCEncoder. Sync encode() passes through input as output (BC data not displayable). Async runEncode() dispatches the encoder and caches results by format+quality+dimensions key. Supports format/quality setters, cache invalidation, and guards against duplicate concurrent encodes. Added tsconfig.json paths mapping and Vite resolve.alias for @vl-ocio/webgpu-bc-encoder package, plus included packages/webgpu-bc-encoder/src in tsconfig include array.
- Files changed: pipeline-checker/src/pipeline/stages/BCCompressStage.ts (new), pipeline-checker/tsconfig.json (paths + include), pipeline-checker/vite.config.ts (resolve.alias)
- Learnings: The BC encoder package wasn't wired as a dependency — needed tsconfig paths + Vite alias for both tsc and bundler resolution. BCEncoder creates its own command encoder internally (not using the shared one), so BCCompressStage.encode() doesn't record GPU commands. The PipelineStage interface is synchronous, so async encoding happens via a separate runEncode() method called before the render loop. noUnusedParameters catches stored-but-never-read private fields.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 22 — 2026-02-21 — 6.2: BCDecompressStage hardware decode
- Implemented: Created src/pipeline/shaders/bc-decompress.wgsl (fullscreen triangle that samples from native BC compressed texture — GPU hardware auto-decompresses). Created src/pipeline/stages/BCDecompressStage.ts implementing PipelineStage: initialize creates linear sampler + rgba32float render target + auto-layout render pipeline; uploadBCData() creates native BC compressed texture via BC_FORMAT_TO_GPU mapping and writeTexture; encode() records fullscreen render pass sampling from BC texture; falls back to passthrough when no BC data available.
- Files changed: pipeline-checker/src/pipeline/shaders/bc-decompress.wgsl (new), pipeline-checker/src/pipeline/stages/BCDecompressStage.ts (new)
- Learnings: Uint8Array from BCEncodeResult.data needs explicit cast to Uint8Array<ArrayBuffer> for writeTexture's GPUAllowSharedBufferSource param (TypeScript strict mode with SharedArrayBuffer). BC decompress uses layout:'auto' since bind group is simple (texture + sampler only). The WGSL shader includes its own VertexOutput struct and vertex shader (not using shared fullscreen-vert.wgsl) since BC decompress uses a filtering sampler, unlike the color stages which use non-filtering.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 23 — 2026-02-21 — 6.3: BC metrics display data infrastructure
- Implemented: Created src/pipeline/types/BCMetrics.ts with PipelineBCMetrics interface (nested ChannelMetrics objects for psnr/maxError/mse, plus encode metadata: compressionRatio, encodedSizeBytes, encodeTimeMs, format, dimensions). Created src/pipeline/utils/computeBCMetrics.ts — async function wrapping encoder's BCMetricsComputer, maps flat BCMetrics fields to nested structure, computes compression ratio (uncompressed rgba32float vs encoded). The actual UI rendering of metrics in stage cards is Phase 7 (StageCard component).
- Files changed: pipeline-checker/src/pipeline/types/BCMetrics.ts (new), pipeline-checker/src/pipeline/utils/computeBCMetrics.ts (new)
- Learnings: BCMetricsComputer already has device internally, so computeBCMetrics doesn't need a device param. The encoder's BCMetrics uses flat naming (psnrR, mseG) while the pipeline's PipelineBCMetrics uses nested objects (psnr.r, mse.g) — the utility bridges the two.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 24 — 2026-02-21 — 6.4: Delta overlay WGSL shader
- Implemented: Created src/pipeline/shaders/bc-delta.wgsl — fragment shader computing abs(original - decompressed) * amplification for BC compression artifact visualization. Binds two texture_2d<f32> inputs (original + decompressed), a sampler, and a DeltaParams uniform with amplification factor (16-byte aligned). Default amplification 10.0. Alpha forced to 1.0. Fullscreen triangle vertex shader included. UI toggle/slider wiring deferred to Phase 7.
- Files changed: pipeline-checker/src/pipeline/shaders/bc-delta.wgsl (new)
- Learnings: Delta shader needs two input textures bound simultaneously (originalTex and decompressedTex), unlike the single-input color stages. The DeltaParams struct is padded to 16 bytes (1 f32 + 3 padding). The delta pipeline in BCDecompressStage will need a separate render pipeline with auto layout since the bind group layout differs from the decompress path.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 25 — 2026-02-21 — 6.5: Graceful fallback when texture-compression-bc unavailable
- Implemented: Added optional `available?: boolean` property to PipelineStage interface (defaults true). BCCompressStage constructor now takes `(device, hasBC)` — when !hasBC, encoder is null, stage auto-disabled. BCDecompressStage constructor now takes `(hasBC)` — when !hasBC, initialize/resize/uploadBCData all early-return. Pipeline passes EXR directly to Stage 4.
- Files changed: PipelineStage.ts, BCCompressStage.ts, BCDecompressStage.ts
- Learnings: Nullable encoder pattern (`BCEncoder | null`) with optional chaining (`this.encoder?.destroy()`) keeps the code clean. Early-return guards in initialize/resize/uploadBCData prevent any GPU resource creation when BC unavailable.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 26 — 2026-02-21 — 6.6: Phase 6 verification gate
- Implemented: Verification-only task. Confirmed all 6 Phase 6 files exist: BCCompressStage.ts, BCDecompressStage.ts, BCMetrics.ts, computeBCMetrics.ts, bc-decompress.wgsl, bc-delta.wgsl. Both stages implement PipelineStage with available/hasBC fallback. Build stable at 297.86 KB.
- Files changed: (checkboxes only)
- Learnings: Phase 6 is complete. All BC infrastructure is in place. UI wiring (format selector, delta toggle, metrics display, "Not Available" labels) will happen in Phase 7.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB, gzip 93.98 KB)

### Iteration 27 — 2026-02-21 — 7.1: Filmstrip component
- Implemented: Created Filmstrip.tsx — horizontal scrollable row of 10 stage cards with arrow connectors (› unicode), visual states (normal/selected/disabled/unavailable), bypass arrow overlay (↷) on disabled stages, "Not Available" label on unavailable stages, enable/disable checkbox per card. Also created StageInfo interface + STAGE_NAMES constant in pipeline/types/StageInfo.ts. Added surface-950 through surface-100 CSS custom properties to index.css for the Phase 7 color palette.
- Files changed: src/components/Filmstrip.tsx (new), src/pipeline/types/StageInfo.ts (new), src/index.css (surface tokens)
- Learnings: Tailwind 4 has no tailwind.config.js — using CSS custom properties (--surface-*) with inline styles instead of Tailwind utility classes for the surface palette. StageCard will be extracted as a separate component in task 7.2. The `available` field on StageInfo maps to `PipelineStage.available` from Phase 6.
- Validation: npx tsc --noEmit (clean), npm run build (298.59 KB, gzip 94.12 KB)

### Iteration 28 — 2026-02-21 — 7.2: StageCard component
- Implemented: Extracted card rendering from Filmstrip.tsx into dedicated StageCard.tsx component. Fixed 160x120px size (160x90 thumbnail + 22px label row). Props: stage, isSelected, onSelect, onToggle. Visual states: normal/selected/disabled/unavailable with opacity transitions. Bypass arrow overlay (↷) on disabled stages, "Not Available" on unavailable stages. Checkbox stops propagation so card selection isn't triggered. Refactored Filmstrip.tsx to import and use StageCard.
- Files changed: src/components/StageCard.tsx (new), src/components/Filmstrip.tsx (refactored)
- Learnings: The StageCard is a self-contained component per the spec. Thumbnail area is placeholder text for now — actual GPU thumbnail rendering (160x90 rgba8unorm blit) will be wired when PipelineRenderer is integrated. Tree-shaking keeps build size identical after refactor.
- Validation: npx tsc --noEmit (clean), npm run build (298.59 KB, gzip 94.12 KB)

### Iteration 29 — 2026-02-21 — 7.3: ControlsPanel component
- Implemented: Created ControlsPanel.tsx with 4 collapsible sections (Input, Color Grading, Tonemap, Output). All controls from the spec are wired: 2 selects in Input, 9 sliders + 7 vec3 sliders + 4 soft-clip sliders + 1 grading space select in Color Grading, 3 selects + 2 toggles + 3 sliders in Tonemap, 1 select + 4 sliders in Output. Uses placeholder inline components (PlaceholderSlider, PlaceholderSelect, PlaceholderToggle, PlaceholderVec3Slider, CollapsibleSection) that will be extracted to reusable components in 7.4. Also created src/types/settings.ts with PipelineSettings interface, Vec3 type, and createDefaultSettings() — task 7.5 will add the full enum constants. Inline enum arrays in ControlsPanel match the spec exactly.
- Files changed: src/components/ControlsPanel.tsx (new), src/types/settings.ts (new)
- Learnings: PipelineSettings type was needed before ControlsPanel could compile, so it was created as part of this task. Task 7.5 will add HDR_COLOR_SPACES, TONEMAP_OPERATORS, BC_FORMATS etc. as exported const arrays to settings.ts and refactor ControlsPanel to import them. The inline PlaceholderSlider/Select/Toggle/Vec3Slider components are functional but will be replaced by the polished reusable components in 7.4. Vec3 RGB channel colors use muted tones (#cc6666, #66cc66, #6666cc) — still neutral enough for color work.
- Validation: npx tsc --noEmit (clean), npm run build (299.06 KB, gzip 94.19 KB)

### Iteration 30 — 2026-02-21 — 7.4: Reusable Slider, Select, Section, Toggle, Vec3Slider components
- Implemented: Created 5 reusable UI primitives in src/components/ui/: Section.tsx (collapsible with chevron), Slider.tsx (labeled slider with click-to-edit value display, double-click-to-reset, unit suffix), Vec3Slider.tsx (RGB channel sliders with muted channel colors at 60% opacity), Select.tsx (labeled dropdown with dark theme), Toggle.tsx (simple switch and segmented button variants). Refactored ControlsPanel.tsx to import and use all 5 components, removing all Placeholder* inline functions and the useState import.
- Files changed: src/components/ui/Section.tsx (new), src/components/ui/Slider.tsx (new), src/components/ui/Vec3Slider.tsx (new), src/components/ui/Select.tsx (new), src/components/ui/Toggle.tsx (new), src/components/ControlsPanel.tsx (refactored)
- Learnings: Slider value editing uses useState + useRef for inline <input> on click. Toggle has two variants: simple (circle thumb on track) for boolean props, segmented buttons (labelOn/labelOff) for named option pairs. All label widths standardized to 96px. The ControlsPanel now adds defaultValue to all Slider/Vec3Slider instances, and uses decimals/unit props for nits and precision controls.
- Validation: npx tsc --noEmit (clean), npm run build (299.22 KB, gzip 94.22 KB)

### Iteration 31 — 2026-02-21 — 7.5: Settings types with enum constants
- Implemented: Added 5 exported `as const` enum constant arrays to src/types/settings.ts: HDR_COLOR_SPACES (9 values with name field), TONEMAP_OPERATORS (12 values), GRADING_SPACES (2 values), BC_FORMATS (7 values with gpuFormat field), ODT_TARGETS (2 values). All arrays match C# enums exactly. Refactored ControlsPanel.tsx to import these constants from settings.ts, removing all inline duplicate arrays.
- Files changed: src/types/settings.ts (enum constants added), src/components/ControlsPanel.tsx (imports refactored)
- Learnings: The `as const` assertion is important — it makes the arrays readonly and narrows the types, matching how the spec defines them. BC_FORMATS includes gpuFormat strings for use with WebGPU createTexture(). HDR_COLOR_SPACES includes a `name` field matching the C# enum member names for display/debugging.
- Validation: npx tsc --noEmit (clean), npm run build (299.22 KB, gzip 94.22 KB)

### Iteration 32 — 2026-02-21 — 7.6: Reset button + usePipeline hook
- Implemented: Created src/types/pipeline.ts with StageState and PipelineState interfaces. Created src/hooks/usePipeline.ts with full pipeline state management: PipelineSettings state (from createDefaultSettings), StageState[] (10 stages, all enabled), selectedStageIndex, derived StageInfo[] for Filmstrip (via useMemo combining StageState + STAGE_NAMES). Locked stages 0 (EXR Load) and 9 (Final Display) cannot be disabled. Added "Reset All" button to ControlsPanel via optional onReset prop with hover effect.
- Files changed: src/types/pipeline.ts (new), src/hooks/usePipeline.ts (new), src/components/ControlsPanel.tsx (onReset prop + button)
- Learnings: The hook produces StageInfo[] as a derived value from internal StageState[] — this keeps the Filmstrip's interface clean. Stage availability (GPU feature gating) and thumbnails are left as placeholders (available=true, thumbnail=null) to be wired when PipelineRenderer is integrated. LOCKED_STAGES Set prevents accidental disabling of first/last stages.
- Validation: npx tsc --noEmit (clean), npm run build (299.22 KB, gzip 94.22 KB)

### Iteration 33 — 2026-02-21 — 7.7: Phase 7 verification gate
- Implemented: Verification-only task. Confirmed all Phase 7 deliverables: 10 component files (Filmstrip, StageCard, ControlsPanel, 5 ui primitives, WebGPUCanvas, DropZone), 2 type files (settings.ts with 5 enum arrays + PipelineSettings + createDefaultSettings, pipeline.ts with StageState + PipelineState), 1 hook file (usePipeline.ts with full state management). All exports verified. Build stable at 299.22 KB. Phase 7 complete.
- Files changed: (checkboxes only)
- Learnings: Phase 7 complete. Wave 3 fully done (Phases 4, 6, 7 all checked). Next is Wave 4: Phase 8 (Preview + Readout) which requires Phases 4 + 6 + 7.
- Validation: npx tsc --noEmit (clean), npm run build (299.22 KB, gzip 94.22 KB)

### Iteration 34 — 2026-02-21 — 8.1: Preview2D component
- Implemented: Created preview-blit.wgsl shader (fullscreen triangle, UV transform by zoom/pan, view exposure via exp2, linear-to-sRGB gamma, out-of-bounds dark border). Created Preview2D.tsx component with: own GPUCanvasContext + render pipeline on mount, ResizeObserver for canvas sizing, render-on-change via requestAnimationFrame, mouse wheel zoom centered on cursor (pixel stays fixed), click-drag pan with pointer capture, double-click fit-to-view (reset zoom=1, pan=0,0), "No image loaded" placeholder when stageTexture is null.
- Files changed: src/shaders/generated/preview-blit.wgsl (new), src/components/Preview2D.tsx (new)
- Learnings: Preview2D creates its own GPUCanvasContext separate from the Phase 1 hidden canvas. The shader uses unfilterable-float + non-filtering sampler (same pattern as pipeline stages) since stage textures are rgba32float. Zoom state update uses functional setZoom to avoid stale closures — pan adjustments happen inside the zoom updater. Container uses ResizeObserver with devicePixelRatio for crisp rendering.
- Validation: npx tsc --noEmit (clean), npm run build (299.50 KB, gzip 94.27 KB)

### Iteration 35 — 2026-02-21 — 8.2: PixelReadout overlay + usePixelReadout hook
- Implemented: Created usePixelReadout.ts hook with requestAnimationFrame throttling (sets needsRead flag on mousemove, reads on next rAF frame). Converts screen coords to texture UV via zoom/pan formula, clamps to texture bounds, calls PixelReadback.readPixel(). Tracks mouseenter/mouseleave for valid state. Returns PixelReadoutState with x, y, r, g, b, a, valid, screenX, screenY. Created PixelReadout.tsx floating tooltip component: semi-transparent dark panel (rgba 0,0,0,0.85), monospace 12px, shows pixel coords and RGBA values with 5 decimal places. Tooltip positioned 16px offset from cursor, flips when near container edges.
- Files changed: src/hooks/usePixelReadout.ts (new), src/components/PixelReadout.tsx (new)
- Learnings: The hook adds screenX/screenY to the readout state so PixelReadout can position itself relative to the container without needing direct mouse event access. PixelReadback's pending guard prevents overlapping GPU reads — the hook doesn't need its own throttle beyond rAF. Both files are tree-shaken in the build until wired into Preview2D/MainPreview (build size unchanged).
- Validation: npx tsc --noEmit (clean), npm run build (299.50 KB, gzip 94.27 KB)

### Iteration 36 — 2026-02-21 — 8.3: MetadataPanel component
- Implemented: Created MetadataPanel.tsx with: ChannelStats interface (min/max tuples), ImageMetadata interface (width, height, channels, fileSizeMB, stats), computeChannelStats() utility function (O(n) scan of Float32Array, called once at EXR load), collapsible section UI using existing Section component (defaultOpen=false). Displays resolution, channels, file size, and per-channel min/max with 5 decimal places. Uses CSS grid layout with monospace font, dark theme inline styles.
- Files changed: src/components/MetadataPanel.tsx (new)
- Learnings: computeChannelStats is exported so it can be called from App.tsx or a data loading hook at EXR load time. The metadata prop is nullable — component renders nothing when no image is loaded. Uses display:contents trick for the channel rows to work within CSS grid.
- Validation: npx tsc --noEmit (clean), npm run build (299.55 KB, gzip 94.29 KB)

### Iteration 37 — 2026-02-21 — 8.4: "View (non-destructive)" section
- Implemented: Created ViewExposureHeader.tsx component placed above the preview canvas. Features: italic "View (non-destructive)" header in muted color, dashed separator line, exposure slider (-10 to +10 EV, step 0.1, default 0.0), formatted display value with sign ("+2.0 EV"), double-click to reset to 0.0. Does NOT affect PipelineSettings — value flows into Preview2D's viewExposure uniform only.
- Files changed: src/components/ViewExposureHeader.tsx (new)
- Learnings: Component is self-contained — accepts exposure/onChange props. Will be placed in a MainPreview container above Preview2D canvas. The accentColor CSS property controls the native slider thumb color. The component uses surface-950 background matching the controls panel for visual consistency.
- Validation: npx tsc --noEmit (clean), npm run build (299.58 KB, gzip 94.30 KB)

### Iteration 38 — 2026-02-21 — 8.5: Phase 8 verification gate
- Implemented: Verification-only task. Confirmed all Phase 8 deliverables: 4 component files (Preview2D, PixelReadout, MetadataPanel, ViewExposureHeader), 1 hook file (usePixelReadout), 1 WGSL shader (preview-blit.wgsl), 1 existing infrastructure file (PixelReadback from Phase 3). All exports verified. Build stable at 299.58 KB. Phase 8 complete. Wave 4 complete.
- Files changed: (checkboxes only)
- Learnings: Phase 8 complete. Wave 4 done. Next is Wave 5: Phase 9 (3D Heightmap) which requires Phase 4 (stage output textures).
- Validation: npx tsc --noEmit (clean), npm run build (299.58 KB, gzip 94.30 KB)

### Iteration 39 — 2026-02-21 — 9.1: Three.js WebGPU renderer + OrbitControls
- Implemented: Created HeightmapView.tsx with HeightmapScene class managing Three.js WebGPU renderer (THREE.WebGPURenderer from 'three/webgpu'), PerspectiveCamera (45 FOV), OrbitControls (damping 0.1), dark scene background (0x0d0d0d). React component with: lazy init on first activation, ResizeObserver for canvas sizing, render loop start/stop on active toggle (preserves camera across tab switches), resetCamera() at 45 deg elevation / 30 deg azimuth. Uses renderAsync for WebGPU compatibility.
- Files changed: src/components/HeightmapView.tsx (new)
- Learnings: Three.js WebGPU types: import from 'three/webgpu' (not 'three'). The package exports map is: three/webgpu → build/three.webgpu.js, three/tsl → build/three.tsl.js, three/addons/* → examples/jsm/*. WebGPURenderer.init() is async — must await before rendering. renderer.setSize with updateStyle=false for manual canvas sizing. Component is tree-shaken until wired into MainPreview.
- Validation: npx tsc --noEmit (clean), npm run build (299.58 KB, gzip 94.30 KB)

### Iteration 40 — 2026-02-22 — 9.7: MainPreview.tsx — [2D] / [3D] tab toggle
- Implemented: Created MainPreview.tsx with 2D/3D tab toggle. Tab bar uses project CSS vars (--surface-600/800, --color-text/text-muted). 2D mode shows Preview2D, 3D mode shows HeightmapView + HeightmapControls. Both views stay mounted (visibility toggled) to preserve state across switches. HeightmapSettings state managed at MainPreview level with createDefaultHeightmapSettings initializer.
- Files changed: src/components/MainPreview.tsx (new)
- Learnings: Preview2D needs device, format, stageTexture, viewExposure props. HeightmapView uses active prop to control render loop. Both components tree-shaken until MainPreview is wired into App.tsx (Phase 10+ integration).
- Validation: npx tsc --noEmit (clean), npm run build (299.58 KB, gzip 94.30 KB)

### Iteration 41 — 2026-02-22 — 9.8/9.9: Verify npm run build passes (Phase 9 complete)
- Implemented: Verification-only task. Ran tsc --noEmit (clean) and npm run build (299.58 KB, gzip 94.30 KB). All Phase 9 tasks complete: HeightmapView with TSL compute, SpriteNodeMaterial billboards, 7 height modes, HeightmapControls, wireframe bounding box, camera shortcuts, and MainPreview 2D/3D tab toggle.
- Files changed: fix_plan.md (checkbox), phase-09-heightmap.md (checkbox)
- Learnings: Phase 9 complete. All components tree-shaken (not wired into App.tsx yet). Next: Phase 10 (build & distribution) and Phase 11 (test verification).
- Validation: npx tsc --noEmit (clean), npm run build (299.58 KB, gzip 94.30 KB)

### Iteration 42 — 2026-02-22 — 10.1: vite-plugin-singlefile config, WGSL ?raw imports, inlineDynamicImports
- Implemented: Verified existing vite.config.ts already has viteSingleFile(), base './', inlineDynamicImports, assetsInlineLimit 100MB, target esnext. Added chunkSizeWarningLimit: 5000 from phase spec. Verified all 10 WGSL imports use ?raw suffix (no fetch()). Verified dist/ contains single index.html (299.58 KB). Also marks phase-10 task 10.2 (WGSL ?raw embedding) since all shaders already use ?raw.
- Files changed: pipeline-checker/vite.config.ts (added chunkSizeWarningLimit)
- Learnings: Config was mostly correct from Phase 1 scaffolding. The chunkSizeWarningLimit suppresses Rollup warnings when the single-file bundle exceeds default 500 KB limit.
- Validation: npx tsc --noEmit (clean), npm run build (299.58 KB single index.html)

### Iteration 43 — 2026-02-22 — 10.2+10.3: Verify file:// protocol + size < 10 MB (Phase 10 complete)
- Implemented: Verification-only task. Confirmed dist/ contains single index.html (299.58 KB, well under 10 MB). Verified HTML has all JS inlined in <script type="module">, CSS inlined in <style>, all WGSL as string literals. No external <script src> or <link stylesheet href> tags. No fetch() for shader files. navigator.gpu init code present. Phase 10 complete.
- Files changed: fix_plan.md (checkboxes), phase-10-build.md (checkboxes)
- Learnings: Phase 10 complete. The 299.58 KB size is because HeightmapView/MainPreview/HeightmapControls are tree-shaken (not wired into App.tsx). Full integration would add Three.js (~1.5 MB). Next: Phase 11 (test verification).
- Validation: npm run build (clean), verified single-file output, size 299.58 KB < 10 MB
