// ============================================================================
// HDRGrade_TextureFX.sdsl
// Standalone HDR Color Grading (no tonemapping)
// ============================================================================
//
// Grade-only shader for use when tonemapping is handled separately or not needed.
// Pipeline: InputSpace → Linear AP1 → GradingSpace → Linear AP1 → OutputSpace
//
// For combined grade + tonemap, use HDRGrade_Tonemap_TextureFX instead.
//
// ============================================================================

shader HDRGrade_TextureFX : FilterBase, HDRGrade
{
    // ========================================================================
    // OUTPUT CONFIGURATION
    // ========================================================================

    // What color space do I need for output?
    // 0=Linear709, 1=Linear2020, 2=ACEScg, 3=ACEScc, 4=ACEScct, 5=sRGB, 6=PQ2020, 7=HLG2020, 8=scRGB
    [EnumType("VL.OCIO.HDRColorSpace, VL.OCIO")]
    int OutputSpace = 0;

    // ========================================================================
    // OUTPUT ENCODING
    // ========================================================================

    // Encode Linear AP1 to any HDRColorSpace
    // Direct paths for AP1 variants, hub through Linear709 for everything else
    float3 EncodeOutput(float3 linearAP1)
    {
        if (OutputSpace == 2)       // ACEScg - already AP1 linear
            return linearAP1;
        else if (OutputSpace == 3)  // ACEScc - log AP1
            return LinearToACEScc(linearAP1);
        else if (OutputSpace == 4)  // ACEScct - log AP1
            return LinearToACEScct(linearAP1);
        else                        // AP1 → Linear709 → target space
            return FromLinearRec709(mul(AP1_to_Rec709, linearAP1), OutputSpace);
    }

    // ========================================================================
    // MAIN FILTER
    // ========================================================================

    float4 Filter(float4 tex0col)
    {
        float3 color = tex0col.rgb;

        // Step 1: Decode input to Linear AP1
        float3 linearAP1 = DecodeInput(color);

        // Step 2: Apply grading in chosen space
        if (GradingSpace == 0)
            linearAP1 = ApplyGradingLog(linearAP1);
        else
            linearAP1 = ApplyGradingLinear(linearAP1);

        // Step 3: Encode to output space
        float3 result = EncodeOutput(linearAP1);

        // Step 4: Vignette (screen-space, applied to encoded output)
        if (VignetteStrength > 0.001)
        {
            float2 centered = streams.TexCoord - 0.5;
            float vigDist = length(centered);
            float vigMask = smoothstep(VignetteRadius, VignetteRadius - VignetteSoftness, vigDist);
            result *= lerp(1.0, vigMask, VignetteStrength);
        }

        return float4(result, tex0col.a);
    }
};
