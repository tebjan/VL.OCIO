// ============================================================================
// TonemapOperators.sdsl
// Base shader with all professional tonemap operators
// ============================================================================
//
// This shader provides tonemap operator implementations used by both:
// - HDRTonemap_TextureFX (FilterBase, full-screen processing)
// - HDRTonemap_ShaderFX (ComputeColor, for composition)
//
// Input-space-aware dispatcher routes each operator to its native space:
// - ACES: AP1 direct when ACEScg input (no round-trip), BT.709 otherwise
// - AgX/Khronos/Lottes: always BT.709 (hardcoded matrices/coefficients)
// - GT/Uncharted2/Reinhard/HejlBurgess: per-channel, applied in input space
// All operators return Linear Rec.709 for the output stage.
//
// Operators:
// - ACES (Stephen Hill approximation with AP1 gamut mapping)
// - AgX (Troy Sobotka, exact analytical curve, Blender default)
// - Gran Turismo V1 / Uchimura (HDR-aware parametric curve)
// - Uncharted 2 / Hable (filmic curve, game industry standard)
// - Khronos PBR Neutral (e-commerce, 13-line official spec)
// - Lottes (Epic Games, luma-based)
// - Reinhard (simple)
// - Reinhard Extended (adjustable white point)
// - Hejl-Burgess (fast approximation)
//
// References:
// - ACES Reference Rendering Transform (Stephen Hill / MJP fit)
// - AgX by Troy Sobotka (https://github.com/sobotka/AgX)
// - AgX exact analytical form (https://github.com/bWFuanVzYWth/AgX)
// - Gran Turismo SIGGRAPH Asia 2018 (Hajime Uchimura)
// - Filmic Tonemapping Operators (John Hable)
// - Khronos PBR Neutral Spec (https://github.com/KhronosGroup/ToneMapping)
// - Hejl-Burgess-Dawson Overview (https://64.github.io/tonemapping/)
//
// ============================================================================

shader TonemapOperators : ColorSpaceConversion
{
    // ========================================================================
    // ACES TONEMAP
    // Stephen Hill approximation of ACES RRT+ODT (from BakingLab)
    // Two paths based on inputSpace:
    //   ACEScg (AP1): RRT_SAT → curve → ODT_SAT → AP1_to_Rec709 (no round-trip)
    //   BT.709:       ACESInputMat → curve → ACESOutputMat (original BakingLab)
    // Always outputs Linear Rec.709
    // ========================================================================

    float3 ACESTonemap(float3 color, int inputSpace)
    {
        float3 v;

        if (inputSpace == 2) // ACEScg — already AP1, just apply RRT saturation
        {
            // RRT_SAT: slight desaturation before curve (factor=0.96)
            // From ACES ref: (1-0.96) * outer(AP1_RGB2Y) + 0.96 * I
            const float3x3 RRT_SAT_MAT = float3x3(
                0.9708890, 0.0269633, 0.00214758,
                0.0108892, 0.9869630, 0.00214758,
                0.0108892, 0.0269633, 0.96214800
            );
            v = mul(RRT_SAT_MAT, color);
        }
        else // BT.709 — combined gamut conversion + RRT saturation
        {
            // ACESInputMat = RRT_SAT * sRGB_to_XYZ * D65_to_D60 * XYZ_to_AP1
            const float3x3 ACESInputMat = float3x3(
                0.59719, 0.35458, 0.04823,
                0.07600, 0.90834, 0.01566,
                0.02840, 0.13383, 0.83777
            );
            v = mul(ACESInputMat, color);
        }

        // RRT+ODT curve (operates on desaturated AP1)
        float3 a = v * (v + 0.0245786) - 0.000090537;
        float3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
        v = a / b;

        if (inputSpace == 2) // AP1 path — ODT saturation then convert to Rec.709
        {
            // ODT_SAT: slight desaturation after curve (factor=0.93)
            const float3x3 ODT_SAT_MAT = float3x3(
                0.949056, 0.0471857, 0.00375827,
                0.019056, 0.9771860, 0.00375827,
                0.019056, 0.0471857, 0.93375800
            );
            v = mul(ODT_SAT_MAT, v);
            return saturate(mul(AP1_to_Rec709, v));
        }
        else // BT.709 path — combined ODT saturation + gamut conversion
        {
            // ACESOutputMat = AP1_to_XYZ * D60_to_D65 * XYZ_to_sRGB * ODT_SAT
            const float3x3 ACESOutputMat = float3x3(
                 1.60475, -0.53108, -0.07367,
                -0.10208,  1.10813, -0.00605,
                -0.00327, -0.07276,  1.07602
            );
            return saturate(mul(ACESOutputMat, v));
        }
    }

    // ========================================================================
    // REINHARD TONEMAP
    // Simple Reinhard (Lmax = infinite)
    // ========================================================================

    float3 ReinhardTonemap(float3 color)
    {
        return color / (color + 1.0);
    }

    // ========================================================================
    // REINHARD EXTENDED TONEMAP
    // Extended Reinhard with adjustable white point
    // ========================================================================

    float3 ReinhardExtendedTonemap(float3 color, float whitePoint)
    {
        float3 numerator = color * (1.0 + color / (whitePoint * whitePoint));
        return numerator / (1.0 + color);
    }

    // ========================================================================
    // UNCHARTED 2 / HABLE TONEMAP
    // Filmic curve from Uncharted 2 (John Hable)
    // Reference: http://filmicworlds.com/blog/filmic-tonemapping-operators/
    // ========================================================================

    float3 Uncharted2Tonemap(float3 color)
    {
        // Curve parameters
        const float A = 0.15; // Shoulder strength
        const float B = 0.50; // Linear strength
        const float C = 0.10; // Linear angle
        const float D = 0.20; // Toe strength
        const float E = 0.02; // Toe numerator
        const float F = 0.30; // Toe denominator
        const float W = 11.2; // Linear white point value

        // Hable's filmic curve function
        float3 curr = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;

        // Apply white scale
        float3 whiteScale = 1.0 / (((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F);

        return curr * whiteScale;
    }

    // ========================================================================
    // KHRONOS PBR NEUTRAL TONEMAP
    // Official Khronos 13-line spec for e-commerce/product visualization
    // Reference: https://github.com/KhronosGroup/ToneMapping/blob/main/PBR_Neutral/README.md
    // ========================================================================

    float3 KhronosPBRTonemap(float3 color)
    {
        const float startCompression = 0.8 - 0.04;
        const float desaturation = 0.15;

        float x = min(color.r, min(color.g, color.b));
        float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
        color -= offset;

        float peak = max(color.r, max(color.g, color.b));
        if (peak < startCompression)
            return color;

        const float d = 1.0 - startCompression;
        float newPeak = 1.0 - d * d / (peak + d - startCompression);
        color *= newPeak / peak;

        float g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);
        return lerp(color, float3(newPeak, newPeak, newPeak), g);
    }

    // ========================================================================
    // HEJL-BURGESS TONEMAP
    // Fast approximation from PS3/Xbox 360 era
    // Reference: https://64.github.io/tonemapping/
    // ========================================================================

    float3 HejlBurgessTonemap(float3 color)
    {
        color = max(0.0, color - 0.004);
        return (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);
    }

    // ========================================================================
    // GRAN TURISMO / UCHIMURA TONEMAP
    // Hajime Uchimura's tonemap from Gran Turismo (HDR-aware)
    // Reference: https://www.desmos.com/calculator/gslcdxvipg
    // ========================================================================

    float3 GranTurismoTonemap(float3 color)
    {
        const float P = 1.0;  // Max display brightness
        const float a = 1.0;  // Contrast
        const float m = 0.22; // Linear section start
        const float l = 0.4;  // Linear section length
        const float c = 1.33; // Black tightness
        const float b = 0.0;  // Pedestal

        float l0 = ((P - m) * l) / a;
        float L0 = m - m / a;
        float L1 = m + (1.0 - m) / a;
        float S0 = m + l0;
        float S1 = m + a * l0;
        float C2 = (a * P) / (P - S1);
        float CP = -C2 / P;

        float3 w0 = 1.0 - smoothstep(0.0, m, color);
        float3 w2 = step(m + l0, color);
        float3 w1 = 1.0 - w0 - w2;

        float3 T = m * pow(color / m, c) + b;
        float3 S = P - (P - S1) * exp(CP * (color - S0));
        float3 L = m + a * (color - m);

        return T * w0 + L * w1 + S * w2;
    }

    // ========================================================================
    // LOTTES TONEMAP
    // Timothy Lottes' tonemap (Epic Games, The Witness)
    // Reference: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl
    // ========================================================================

    float3 LottesTonemap(float3 color)
    {
        const float a = 1.6;
        const float d = 0.977;
        const float hdrMax = 8.0;
        const float midIn = 0.18;
        const float midOut = 0.267;

        // Luminance coefficients (Rec.709)
        const float3 lumaCoeff = float3(0.2126, 0.7152, 0.0722);

        float luma = dot(color, lumaCoeff);
        float toneMappedLuma = (luma * (1.0 + luma / (hdrMax * hdrMax))) / (1.0 + luma);

        // Toe section
        toneMappedLuma = pow(toneMappedLuma, d);

        // Apply to color
        return color * (toneMappedLuma / max(luma, 1e-5));
    }

    // ========================================================================
    // AGX TONEMAP
    // Troy Sobotka's AgX with exact analytical sigmoid (no LUT needed)
    // Input: Linear BT.709 (Rec.709), 16.5 stops dynamic range
    // Reference: https://github.com/sobotka/AgX
    // Exact curve: https://github.com/bWFuanVzYWth/AgX
    // ========================================================================

    // Exact analytical AgX sigmoid - mathematically identical to the
    // AgX_Default_Contrast.spi1d LUT (NOT a polynomial approximation)
    float3 AgXSigmoid(float3 v)
    {
        const float threshold = 0.6060606060606061;  // 20/33
        const float a_up = 69.86278913545539;
        const float a_down = 59.507875;
        const float b_up = 3.25;   // 13/4
        const float b_down = 3.0;  // 3/1
        const float c_up = -0.30769230769230771;   // -4/13
        const float c_down = -0.33333333333333333;  // -1/3

        float3 mask = step(v, float3(threshold, threshold, threshold));
        float3 a = a_up + (a_down - a_up) * mask;
        float3 b = b_up + (b_down - b_up) * mask;
        float3 c = c_up + (c_down - c_up) * mask;

        return 0.5 + ((-2.0 * threshold) + 2.0 * v)
             * pow(1.0 + a * pow(abs(v - threshold), b), c);
    }

    float3 AgXTonemap(float3 color)
    {
        // AgX log encoding range: 16.5 stops (-12.47 to +4.03 EV)
        const float min_ev = -12.47393;
        const float max_ev = 4.026069;
        const float dynamic_range = max_ev - min_ev;

        // Inset matrix: BT.709 to AgX primaries (chroma compression + rotation)
        const float3x3 agx_mat = float3x3(
            0.842479062253094,  0.0784335999999992, 0.0792237451477643,
            0.0423282422610123, 0.878468636469772,  0.0791661274605434,
            0.0423756549057051, 0.0784336,          0.879142973793104
        );

        // Outset matrix: AgX primaries to BT.709 (expand chromaticity)
        const float3x3 agx_mat_inv = float3x3(
             1.19687900512017,   -0.0528968517574562, -0.0529716355144438,
            -0.0980208811401368,  1.15190312990417,   -0.0980434501171241,
            -0.0990297440797205, -0.0989611768448433,  1.15107367264116
        );

        // Apply inset matrix (compress primaries toward achromatic)
        color = mul(agx_mat, color);

        // Log2 encoding, normalize to [0, 1]
        color = clamp(log2(max(color, 1e-10)), min_ev, max_ev);
        color = (color - min_ev) / dynamic_range;

        // Apply exact analytical sigmoid curve
        color = AgXSigmoid(color);

        // Apply outset matrix (expand chromaticity back out)
        color = mul(agx_mat_inv, color);

        return saturate(color);
    }

    // ========================================================================
    // TONEMAP DISPATCHER
    // Routes each operator to its native working space:
    //   ACES: AP1 direct path when inputSpace==ACEScg, BT.709 otherwise
    //   AgX/Khronos/Lottes: always BT.709 (hardcoded matrices/coefficients)
    //   GT/Uncharted2/Reinhard/HejlBurgess: space-agnostic per-channel curves,
    //     applied in input space, then converted to Rec.709 for output
    // All paths return Linear Rec.709
    // ========================================================================

    float3 ApplyTonemap(float3 color, int inputSpace, int op, float exposure, float whitePoint)
    {
        // ACES: direct AP1 path when input is ACEScg (skip Rec.709 round-trip)
        if (op == 1)
        {
            if (inputSpace == 2) // ACEScg — feed AP1 directly
            {
                color *= exp2(exposure);
                return ACESTonemap(color, 2);
            }
            else // All other inputs — convert to Rec.709, ACES handles internally
            {
                float3 lin709 = ToLinearRec709(color, inputSpace);
                lin709 *= exp2(exposure);
                return ACESTonemap(lin709, 0);
            }
        }

        // Space-agnostic per-channel curves: apply in input space, convert after
        if (op == 3 || op == 4 || op == 7 || op == 8 || op == 9)
        {
            // For linear spaces: keep in native gamut, apply curve, convert after
            // For non-linear (log/gamma/PQ/HLG): decode to Rec.709 first
            float3 linColor = color;
            int linSpace = inputSpace;

            if (inputSpace > 2) // Non-linear: decode via hub to Rec.709
            {
                linColor = ToLinearRec709(color, inputSpace);
                linSpace = 0;
            }

            linColor *= exp2(exposure);

            // Apply per-channel curve in current linear space
            float3 tonemapped = linColor;
            if (op == 3)
                tonemapped = GranTurismoTonemap(linColor);
            else if (op == 4)
                tonemapped = Uncharted2Tonemap(linColor);
            else if (op == 7)
                tonemapped = ReinhardTonemap(linColor);
            else if (op == 8)
                tonemapped = ReinhardExtendedTonemap(linColor, whitePoint);
            else
                tonemapped = HejlBurgessTonemap(linColor);

            // Convert to Rec.709 for output stage
            if (linSpace == 1)
                return mul(Rec2020_to_Rec709, tonemapped);
            else if (linSpace == 2)
                return mul(AP1_to_Rec709, tonemapped);
            else
                return tonemapped;
        }

        // BT.709-native operators: always convert to Rec.709 first
        float3 lin709 = ToLinearRec709(color, inputSpace);
        lin709 *= exp2(exposure);

        if (op == 0)
            return lin709;                                  // None (passthrough)
        else if (op == 2)
            return AgXTonemap(lin709);                      // AgX (BT.709 inset matrix)
        else if (op == 5)
            return KhronosPBRTonemap(lin709);               // Khronos PBR (BT.709 spec)
        else if (op == 6)
            return LottesTonemap(lin709);                   // Lottes (BT.709 luma)
        else
            return lin709;                                   // Fallback
    }
};
