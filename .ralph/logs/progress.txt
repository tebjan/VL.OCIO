### Iteration 1 — 2026-02-21 — 1.1: Initialize Vite + React 19 + TypeScript + Tailwind 4 project
- Implemented: Created pipeline-checker/ with package.json (React 19, Three.js, Vite 6, Tailwind 4, vite-plugin-singlefile), vite.config.ts (base ./, asset inlining, single-file build), tsconfig.json + tsconfig.node.json, index.html with dark BG flash prevention, src/index.css (Tailwind v4 @import + dark theme CSS vars), src/main.tsx, src/App.tsx (minimal placeholder), type declarations for .wgsl?raw and .exr imports, and webgpu.d.ts reference.
- Files changed: pipeline-checker/package.json, vite.config.ts, tsconfig.json, tsconfig.node.json, index.html, src/index.css, src/main.tsx, src/App.tsx, src/types/raw-imports.d.ts, src/types/webgpu.d.ts
- Learnings: Tailwind v4 uses @tailwindcss/vite plugin instead of postcss.config.js. No tailwind.config.js needed. App.tsx is a minimal placeholder — WebGPUContext and DropZone are separate tasks (1.2, 1.3).
- Validation: npm install (0 vulnerabilities), npx tsc --noEmit (clean), npm run build (200 KB single HTML)

### Iteration 2 — 2026-02-21 — 1.2: WebGPU device initialization
- Implemented: Created src/gpu/WebGPUContext.ts with GPUContext interface (adapter, device, format, canvasContext, hasBC), initWebGPU() async function that requests high-performance adapter, conditionally enables texture-compression-bc, sets 256MB storage/buffer limits, configures canvas with premultiplied alpha, and handles device.lost.
- Files changed: pipeline-checker/src/gpu/WebGPUContext.ts
- Learnings: Extended GPUContext interface beyond spec template to include canvasContext and hasBC flag for downstream use. device.lost handler logs but doesn't auto-recover yet.
- Validation: npx tsc --noEmit (clean), npm run build (201 KB single HTML)

### Iteration 3 — 2026-02-21 — 1.3: EXR drop zone component + Try sample button
- Implemented: Created DropZone.tsx with drag-drop EXR support (Three.js EXRLoader, half-float conversion), procedural HDR sample generator (256x256 hue/brightness gradient), drag counter pattern for flicker prevention. Created WebGPUCanvas.tsx (hidden 1x1 canvas for WebGPU context). Updated App.tsx with state machine (initializing/error/ready/loaded), WebGPU init on mount, DropZone integration.
- Files changed: pipeline-checker/src/components/DropZone.tsx (new), pipeline-checker/src/components/WebGPUCanvas.tsx (new), pipeline-checker/src/App.tsx (rewritten)
- Learnings: Used procedural sample generation instead of importing a .exr asset file — avoids build dependency on a binary asset. Task 1.5 in phase file was merged into 1.3 in fix_plan.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML)

### Iteration 4 — 2026-02-21 — 1.4: Dark theme setup
- Implemented: Verified dark theme was already complete from iteration 1. All CSS custom properties match spec exactly: --color-bg #0d0d0d, --color-surface #1a1a1a, --color-border #2a2a2a, --color-text #e0e0e0, --color-text-muted #808080, --color-accent #4a4a4a, --color-accent-hover #5a5a5a, --color-error #cc4444. No saturated accent colors anywhere. White-flash prevention inline style in index.html. Scrollbar theming.
- Files changed: None (theme was already correct; only checkboxes updated)
- Learnings: Task 1.4 was effectively completed during 1.1 when index.css was created. All components already use CSS vars, no hardcoded saturated colors.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML), grep confirmed no saturated color literals in src/

### Iteration 5 — 2026-02-21 — 1.5: Phase 1 final verification
- Implemented: Ran all three verification commands. npm install (0 vulnerabilities, 98 packages), npx tsc --noEmit (clean), npm run build (296 KB single HTML). Phase 1 is fully complete.
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 1 complete. Wave 1 done. Next is Wave 2: Phase 3 (WebGPU Render Pipeline) or Phase 5 (BC Encoder). Phase 3 should come first since Phase 4 depends on it.
- Validation: npm install (clean), npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 6 — 2026-02-21 — 3.1: PipelineStage interface
- Implemented: Created src/pipeline/PipelineStage.ts with the PipelineStage interface — name, index, enabled, output properties + initialize/resize/encode/destroy lifecycle methods. encode() takes GPUCommandEncoder, GPUTexture (input), GPUBuffer (uniforms).
- Files changed: pipeline-checker/src/pipeline/PipelineStage.ts (new)
- Learnings: Section file clarifies encode() takes GPUBuffer (not PipelineSettings type), keeping the interface dependency-free. PipelineSettings type comes in task 3.5.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 7 — 2026-02-21 — 3.2: FragmentStage implementation
- Implemented: Created src/pipeline/FragmentStage.ts implementing PipelineStage. Includes embedded fullscreen triangle vertex shader (no external file), bind group layout (unfilterable-float texture + non-filtering sampler + uniform buffer), GPURenderPipeline creation with rgba32float target (blend: undefined), encode() with per-frame bind group, render target with RENDER_ATTACHMENT | TEXTURE_BINDING | COPY_SRC. Constructor takes (name, index, fragmentWGSL) — vertex shader is prepended automatically.
- Files changed: pipeline-checker/src/pipeline/FragmentStage.ts (new)
- Learnings: tsconfig has noUnusedLocals — removed width/height private fields that were stored but never read. The vertex shader is embedded as a string constant per section-03 spec ("embedded as a constant string in FragmentStage.ts"). The fullscreen-quad.wgsl file (task 4.7) can refactor this later if needed.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 8 — 2026-02-21 — 3.3: PipelineRenderer orchestrator
- Implemented: Created src/pipeline/PipelineRenderer.ts — stage orchestrator with: constructor creates 512-byte uniform buffer, setStages() registers stages, setSize() initializes (first call) or resizes (subsequent) all stages, render() chains enabled stages in single command buffer (disabled stages bypass transparently), getStageOutput() walks backwards to find last enabled stage, updateUniforms() writes raw Float32Array to GPU buffer, destroy() cleans up all resources.
- Files changed: pipeline-checker/src/pipeline/PipelineRenderer.ts (new)
- Learnings: WebGPU TypeScript types require Float32Array<ArrayBuffer> (not Float32Array<ArrayBufferLike>) for writeBuffer compatibility. Fixed spec's setSize bug where this.width was set before the initialization check. The PipelineSettings typed interface comes in 3.5 — for now updateUniforms takes raw Float32Array.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 9 — 2026-02-21 — 3.4: Render target management
- Implemented: Created src/pipeline/TextureUtils.ts with shared utilities: BYTES_PER_PIXEL (16) and ROW_ALIGNMENT (256) constants, alignedBytesPerRow() for 256-byte readback alignment, copyAlignedToContiguous() for stripping row padding from mapped buffers, uploadFloat32Texture() for writing Float32Array RGBA data to GPUTexture (TEXTURE_BINDING | COPY_SRC | COPY_DST). Render target creation itself was already in FragmentStage (RENDER_ATTACHMENT | TEXTURE_BINDING | COPY_SRC).
- Files changed: pipeline-checker/src/pipeline/TextureUtils.ts (new)
- Learnings: writeTexture (upload) does NOT require 256-byte bytesPerRow alignment — only copyTextureToBuffer (readback) does. Upload uses width*16 directly. The upload texture needs COPY_DST (for upload) while stage render targets don't (they write via render passes).
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 10 — 2026-02-21 — 3.5: PipelineUniforms
- Implemented: Created src/pipeline/PipelineUniforms.ts with: PipelineSettings interface (all 30+ fields covering stages 4-9 + toggles + BC + view), DEFAULT_SETTINGS constant (neutral grading, no tonemap, passthrough), serializeUniforms() that writes to a shared Float32Array/Int32Array (512 bytes). Layout matches WGSL struct with vec3+pad pattern: 10 scalars, 2-float pad, 7x vec3+pad blocks, 4 more scalars, 6 tonemap fields, 2 remap fields, 3 toggle i32s, 2 BC i32s, 1 view float. Total ~232 bytes used of 512.
- Files changed: pipeline-checker/src/pipeline/PipelineUniforms.ts (new)
- Learnings: serializeUniforms returns Float32Array<ArrayBuffer> (matching PipelineRenderer.updateUniforms signature). The _pad0 at offset 40 is vec2<f32> (8 bytes) to align the first vec3 (lift) to 16-byte boundary at offset 48. All subsequent vec3s naturally align because each is 12+4=16 bytes.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 11 — 2026-02-21 — 3.6: PixelReadback utility
- Implemented: Created src/pipeline/PixelReadback.ts with async readPixel(texture, x, y) method. Uses pending flag for debounce (returns null if previous read in-flight). Creates 256-byte staging buffer per read (minimum for bytesPerRow alignment), copyTextureToBuffer for single pixel, mapAsync + getMappedRange to extract [R,G,B,A] Float32Array(4). Buffer destroyed after each read.
- Files changed: pipeline-checker/src/pipeline/PixelReadback.ts (new)
- Learnings: Even single-pixel readback requires 256-byte bytesPerRow alignment. Throttling to 30Hz is handled by the caller (Phase 8 UI), not by this class. try/finally ensures pending flag is always reset even on error.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 12 — 2026-02-21 — 3.7: Phase 3 final verification
- Implemented: Ran full verification suite. All 6 pipeline files present: PipelineStage.ts, FragmentStage.ts, PipelineRenderer.ts, TextureUtils.ts, PipelineUniforms.ts, PixelReadback.ts. npm install (0 vulnerabilities), npx tsc --noEmit (clean), npm run build (296 KB single HTML). Phase 3 is fully complete.
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 3 complete. Wave 2 Phase 3 done. Next is either Phase 5 (BC Encoder Package) or skip to Wave 3 Phase 4 (Color Pipeline WGSL Shaders) — but Phase 4 requires Phase 3 which is now done. Phase 5 (BC) is optional per dependency rules. Follow fix_plan.md order: Phase 5 next.
- Validation: npm install (clean), npx tsc --noEmit (clean), npm run build (296 KB)
