using System.Collections.Immutable;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using VL.Core;

namespace VL.OCIO;

/// <summary>
/// Represents a single color grading instance that can be controlled via the web UI.
/// The service starts automatically — just place this node and the web UI becomes available.
///
/// Settings are persisted as a JSON dictionary in the "Settings" Create pin (constructor parameter),
/// keyed by stable instance ID (deterministic hash of path stack + auto-assigned slice index).
/// This supports multiple runtime instances from the same physical node (e.g. inside a loop).
/// Slice indices are auto-managed: vvvv creates instances in deterministic order, so
/// slice 0 always gets index 0, slice 1 gets index 1, etc. On restart the same mapping holds.
///
/// In editor mode, the service calls SetPinValue (DontCompile) to persist changes + SetRuntimeState for immediate output.
/// In exported mode, the service uses JSON files + SetRuntimeState for immediate output.
/// </summary>
[ProcessNode]
public class ColorGradingInstance : IDisposable
{
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) }
    };

    // --- Static per-path slice index tracking ---
    // Tracks how many alive instances exist per node path.
    // When a constructor runs, it gets index = current alive count, then increments.
    // When all instances for a path are disposed, the counter resets to 0.
    // This gives deterministic indices because vvvv creates loop slices in order.
    private static readonly Dictionary<string, int> _pathAliveCounts = new();
    private static readonly object _counterLock = new();

    private readonly NodeContext _nodeContext;
    private readonly string _pathKey;
    private readonly int _sliceIndex;
    private readonly string _stableId;
    private readonly string _autoGeneratedId;
    private readonly bool _isExported;
    private readonly ColorGradingService _service;
    private string _lastDisplayName = "";
    private bool _registered;
    private bool _lastPublishToNetwork;

    // Parsed settings from the "Settings" Create pin (constructor parameter, persisted in document)
    private readonly ProjectSettings _parsedSettings;

    // Track last defaults sent to service (for change detection)
    private ColorCorrectionSettings? _lastDefaultCC;
    private TonemapSettings? _lastDefaultTM;
    private string _lastDefaultFilePath = "";

    // Runtime state overrides from web UI (overrides Create pin defaults in ALL modes)
    private ColorCorrectionSettings? _runtimeColorCorrection;
    private TonemapSettings? _runtimeTonemap;
    private string? _runtimeInputFilePath;
    private bool _hasRuntimeState;

    /// <summary>
    /// Create a color grading instance.
    /// Slice index is auto-assigned based on creation order within the same node path.
    /// Works correctly inside ForEach loops — each slice gets a unique, stable identity.
    /// </summary>
    /// <param name="nodeContext">Injected by vvvv</param>
    /// <param name="settings">Persisted settings JSON (managed automatically)</param>
    public ColorGradingInstance(NodeContext nodeContext, string settings = "")
    {
        _nodeContext = nodeContext;
        _isExported = nodeContext.AppHost.IsExported;

        // Compute path key and auto-assign slice index
        _pathKey = StackToString(nodeContext.Path.Stack);
        lock (_counterLock)
        {
            int aliveCount = _pathAliveCounts.GetValueOrDefault(_pathKey, 0);
            _sliceIndex = aliveCount;
            _pathAliveCounts[_pathKey] = aliveCount + 1;
        }

        _stableId = ComputeStableId(nodeContext.Path.Stack, _sliceIndex);
        _autoGeneratedId = GenerateFriendlyId(nodeContext, _sliceIndex);
        _service = ColorGradingService.GetOrCreate(nodeContext.AppHost);

        // Parse the Create pin settings — try dictionary format first, then legacy single format
        _parsedSettings = ParseMySettings(settings);

        Console.WriteLine($"[ColorGradingInstance] Created '{_autoGeneratedId}' id={_stableId} slice={_sliceIndex} (exported: {_isExported})");
    }

    /// <summary>
    /// Main update method called every frame by VVVV.
    /// The "Settings" Create pin (constructor) holds a JSON dictionary keyed by stable instance ID.
    /// The service updates this pin via SetPinValue (DontCompile) when settings change in the web UI.
    /// Runtime state (from SetRuntimeState) provides immediate output updates without node recreation.
    /// </summary>
    /// <param name="outColorCorrection">Output: effective color correction settings</param>
    /// <param name="outTonemap">Output: effective tonemap settings</param>
    /// <param name="effectiveInstanceId">Output: the actual instance ID being used</param>
    /// <param name="uiUrl">Output: URL to reach the color grading web UI</param>
    /// <param name="clientCount">Output: number of connected web UI clients</param>
    /// <param name="customInstanceId">Custom instance ID (empty = auto-generated from patch path)</param>
    /// <param name="publishToNetwork">Make the grading UI accessible on the local network (requires one-time admin permission)</param>
    /// <param name="autoOpenBrowser">Automatically open the web UI in the default browser (checks for existing connections first)</param>
    public void Update(
        out ColorCorrectionSettings outColorCorrection,
        out TonemapSettings outTonemap,
        out string effectiveInstanceId,
        out string uiUrl,
        out int clientCount,
        string customInstanceId = "",
        bool publishToNetwork = false,
        bool autoOpenBrowser = true)
    {
        // Display name: custom or auto-generated from patch path
        string displayName = string.IsNullOrWhiteSpace(customInstanceId)
            ? _autoGeneratedId
            : customInstanceId.Trim();

        // Register once (stable ID is deterministic for this node path + slice index)
        if (!_registered)
        {
            _service.RegisterInstance(
                _stableId,
                displayName,
                _nodeContext.Path.Stack,
                _isExported,
                this,
                _parsedSettings.ColorCorrection,
                _parsedSettings.Tonemap,
                _parsedSettings.InputFilePath,
                _parsedSettings.PresetName);

            _lastDisplayName = displayName;
            _registered = true;
        }
        else if (displayName != _lastDisplayName)
        {
            // Display name changed — update it without re-registering
            _service.UpdateInstanceDisplayName(_stableId, displayName);
            _lastDisplayName = displayName;
        }

        effectiveInstanceId = displayName;

        // Publish to network: when toggled on, upgrade the server to LAN-accessible
        if (publishToNetwork && !_lastPublishToNetwork)
        {
            _service.EnableNetworkAccess();
        }
        _lastPublishToNetwork = publishToNetwork;

        // Update defaults if registered and values changed
        if (_registered)
        {
            bool defaultsChanged = _parsedSettings.ColorCorrection != _lastDefaultCC ||
                                   _parsedSettings.Tonemap != _lastDefaultTM ||
                                   _parsedSettings.InputFilePath != _lastDefaultFilePath;

            if (defaultsChanged)
            {
                _service.UpdateInstanceDefaults(
                    _stableId,
                    _parsedSettings.ColorCorrection,
                    _parsedSettings.Tonemap,
                    _parsedSettings.InputFilePath);

                _lastDefaultCC = _parsedSettings.ColorCorrection;
                _lastDefaultTM = _parsedSettings.Tonemap;
                _lastDefaultFilePath = _parsedSettings.InputFilePath;
            }
        }

        // Auto-open browser if requested (safe to call every frame — service deduplicates)
        if (autoOpenBrowser && _registered)
            _service.RequestBrowserOpen();

        // Determine output values: runtime override (from web UI) takes priority,
        // then falls back to Create pin defaults (parsed in constructor)
        if (_hasRuntimeState)
        {
            outColorCorrection = _runtimeColorCorrection ?? _parsedSettings.ColorCorrection;
            outTonemap = _runtimeTonemap ?? _parsedSettings.Tonemap;
        }
        else
        {
            outColorCorrection = _parsedSettings.ColorCorrection;
            outTonemap = _parsedSettings.Tonemap;
        }

        // Diagnostic outputs from the service
        uiUrl = _service.UiUrl;
        clientCount = _service.ClientCount;
    }

    /// <summary>
    /// Called by the service to set runtime state that overrides Create pin defaults.
    /// Internal: only used by ColorGradingService, must not appear as a vvvv pin.
    /// </summary>
    internal void SetRuntimeState(
        ColorCorrectionSettings? colorCorrection,
        TonemapSettings? tonemap,
        string? inputFilePath)
    {
        _runtimeColorCorrection = colorCorrection;
        _runtimeTonemap = tonemap;
        _runtimeInputFilePath = inputFilePath;
        _hasRuntimeState = colorCorrection != null || tonemap != null || inputFilePath != null;
    }

    /// <summary>
    /// Clear runtime state, reverting to Create pin defaults.
    /// Internal: only used by ColorGradingService.
    /// </summary>
    internal void ClearRuntimeState()
    {
        _runtimeColorCorrection = null;
        _runtimeTonemap = null;
        _runtimeInputFilePath = null;
        _hasRuntimeState = false;
    }

    /// <summary>
    /// Get the node stack for SetPinValue operations (editor mode).
    /// </summary>
    internal ImmutableStack<UniqueId> GetNodeStack() => _nodeContext.Path.Stack;

    /// <summary>
    /// The stable ID for this instance (deterministic hash of path stack + slice index).
    /// </summary>
    internal string StableId => _stableId;

    /// <summary>
    /// Whether this instance is running in exported (standalone) mode.
    /// </summary>
    internal bool IsExported => _isExported;

    /// <summary>
    /// Parse settings from the Create pin JSON string.
    /// Tries dictionary format first (keyed by stable ID), then legacy single-object format.
    /// </summary>
    private ProjectSettings ParseMySettings(string settings)
    {
        if (string.IsNullOrWhiteSpace(settings))
            return new ProjectSettings();

        // Try dictionary format: { "stableId1": {...}, "stableId2": {...} }
        try
        {
            var dict = JsonSerializer.Deserialize<Dictionary<string, ProjectSettings>>(settings, JsonOptions);
            if (dict != null && dict.TryGetValue(_stableId, out var mySettings))
                return mySettings;
            // Dictionary parsed but our ID not found — could be a new loop iteration
            if (dict != null && dict.Count > 0)
                return new ProjectSettings();
        }
        catch
        {
            // Not a dictionary — try legacy single format
        }

        // Legacy single-object format: { "colorCorrection": {...}, "tonemap": {...} }
        try
        {
            return ProjectSettings.FromJson(settings) ?? new ProjectSettings();
        }
        catch
        {
            return new ProjectSettings();
        }
    }

    /// <summary>
    /// Compute a stable, deterministic instance ID from the node's path stack and slice index.
    /// Path stack identifies the node in the document (same for all loop iterations).
    /// Slice index differentiates loop slices (auto-assigned by creation order).
    /// UniqueIds are document-stored GUIDs, so the hash is stable across sessions.
    /// Uses FNV-1a hash for determinism (no runtime randomization like string.GetHashCode).
    /// </summary>
    private static string ComputeStableId(ImmutableStack<UniqueId> stack, int sliceIndex)
    {
        var sb = new StringBuilder();
        foreach (var id in stack)
        {
            if (sb.Length > 0) sb.Append('/');
            sb.Append(id.ToString());
        }
        // Append slice index to differentiate loop slices sharing the same path
        sb.Append('#');
        sb.Append(sliceIndex);

        // FNV-1a 32-bit hash — deterministic across sessions
        unchecked
        {
            uint hash = 2166136261u;
            var str = sb.ToString();
            for (int i = 0; i < str.Length; i++)
            {
                hash ^= str[i];
                hash *= 16777619u;
            }
            return hash.ToString("X8");
        }
    }

    /// <summary>
    /// Convert an ImmutableStack to a string key for path-based grouping.
    /// </summary>
    private static string StackToString(ImmutableStack<UniqueId> stack)
    {
        var sb = new StringBuilder();
        foreach (var id in stack)
        {
            if (sb.Length > 0) sb.Append('/');
            sb.Append(id.ToString());
        }
        return sb.ToString();
    }

    /// <summary>
    /// Generate a friendly display name from the patch path.
    /// Uses GetCallingPatches() to get the parent patch names.
    /// Skips "ColorGrading" suffix. Falls back to app name.
    /// For looped nodes (sliceIndex > 0), appends the index for clarity.
    /// </summary>
    private static string GenerateFriendlyId(NodeContext nodeContext, int sliceIndex)
    {
        // For single use (index 0): no suffix needed (dedup handles duplicates via #N)
        // For looped use (index > 0): show the slice index
        string suffix = sliceIndex > 0 ? $" [{sliceIndex}]" : "";

        string baseName = "";
        try
        {
            // GetCallingPatches() returns parent patches innermost-first:
            // e.g. node in App > Scene > ColorGrading → [Scene, App]
            var patches = nodeContext.GetCallingPatches();
            foreach (var patch in patches)
            {
                var name = patch.Name;
                if (string.IsNullOrWhiteSpace(name))
                    continue;

                // Skip if the patch name IS our node type
                if (name.StartsWith("ColorGrading", StringComparison.OrdinalIgnoreCase))
                    continue;

                baseName = name;
                break;
            }
        }
        catch
        {
            // GetCallingPatches() may not be available in all contexts
        }

        if (string.IsNullOrEmpty(baseName))
        {
            try
            {
                baseName = nodeContext.AppHost.AppName;
            }
            catch
            {
                baseName = "Instance";
            }
        }

        return baseName + suffix;
    }

    public void Dispose()
    {
        if (_registered)
        {
            _service.UnregisterInstance(_stableId);
            _registered = false;
        }

        // Decrement alive count for this path; reset when all instances are gone
        lock (_counterLock)
        {
            int count = _pathAliveCounts.GetValueOrDefault(_pathKey, 1) - 1;
            if (count <= 0)
                _pathAliveCounts.Remove(_pathKey);
            else
                _pathAliveCounts[_pathKey] = count;
        }

        Console.WriteLine($"[ColorGradingInstance] Disposed '{_autoGeneratedId}' ({_stableId}) slice={_sliceIndex}");
    }
}
