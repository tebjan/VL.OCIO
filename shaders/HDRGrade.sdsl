// ============================================================================
// HDRGrade.sdsl
// Base mixin: grading parameters and methods for HDR color grading
// ============================================================================
//
// Provides the grading pipeline used by both:
// - HDRGrade_TextureFX (standalone grade, no tonemap)
// - HDRGrade_Tonemap_TextureFX (combined grade + tonemap)
//
// Pipeline: InputSpace → Linear AP1 → GradingSpace → Linear AP1
//
// Two grading workflows:
//   - Log (ACEScct): Colorist workflow (DaVinci Resolve style)
//   - Linear (ACEScg): VFX compositing workflow (Nuke style)
//
// Does NOT declare OutputSpace — each consumer defines its own.
//
// ============================================================================

shader HDRGrade : ColorSpaceConversion
{
    // ========================================================================
    // PIPELINE SETTINGS
    // ========================================================================

    // What color space is my input?
    // 0=Linear709, 1=Linear2020, 2=ACEScg, 3=ACEScc, 4=ACEScct, 5=sRGB, 6=PQ2020, 7=HLG2020, 8=scRGB
    [EnumType("VL.OCIO.HDRColorSpace, VL.OCIO")]
    int InputSpace = 0;

    // Where should grading math happen?
    [EnumType("VL.OCIO.GradingSpace, VL.OCIO")]
    int GradingSpace = 0;  // 0=Log (ACEScct), 1=Linear (ACEScg)

    // ========================================================================
    // GRADING PARAMETERS
    // ========================================================================

    // Exposure in stops (-8 to +8 typical range)
    float Exposure = 0.0;

    // Contrast multiplier (0.5 to 2.0 typical)
    float Contrast = 1.0;

    // Saturation (0 = grayscale, 1 = normal, 2 = oversaturated)
    float Saturation = 1.0;

    // White balance adjustments
    float Temperature = 0.0;  // negative = cooler (blue), positive = warmer (orange)
    float Tint = 0.0;         // negative = magenta, positive = green

    // Tonal range controls (Lightroom-style)
    float Highlights = 0.0;  // -1 to +1: compress/expand bright regions
    float Shadows = 0.0;     // -1 to +1: lift/crush dark regions

    // Smart saturation (protects already-saturated colors)
    float Vibrance = 0.0;    // -1 to +2: boost low-saturation, protect high-saturation

    // ASC-CDL style controls
    float3 Lift = float3(0, 0, 0);   // Shadow offset
    float3 Gamma = float3(1, 1, 1);  // Midtone power
    float3 Gain = float3(1, 1, 1);   // Highlight multiplier
    float3 Offset = float3(0, 0, 0); // Post-grade offset

    // Color wheels (shadow/midtone/highlight tinting)
    float3 ShadowColor = float3(0, 0, 0);
    float3 MidtoneColor = float3(0, 0, 0);
    float3 HighlightColor = float3(0, 0, 0);

    // Soft clipping
    float HighlightSoftClip = 0.0;
    float ShadowSoftClip = 0.0;
    float HighlightKnee = 1.0;
    float ShadowKnee = 0.1;

    // Screen-space vignette
    float VignetteStrength = 0.0;   // 0 to 1
    float VignetteRadius = 0.7;     // 0 to 1, distance from center where falloff begins
    float VignetteSoftness = 0.3;   // 0 to 1, feather width

    // ========================================================================
    // SHARED UTILITIES
    // ========================================================================

    // Zone weights for color wheels and highlight/shadow controls.
    // Thresholds are tuned for normalized ACEScct luma where mid-gray ≈ 0.42.
    // Shadow fades out at mid-gray, highlight fades in just below mid-gray.
    float3 GetZoneWeights(float luma)
    {
        float shadow = 1.0 - smoothstep(0.0, 0.5, luma);
        float highlight = smoothstep(0.35, 0.65, luma);
        float mid = 1.0 - shadow - highlight;
        return float3(shadow, mid, highlight);
    }

    // Branchless soft clip
    float3 ApplySoftClip(float3 val, float hKnee, float hStr, float sKnee, float sStr)
    {
        // Highlight compression
        float3 hExcess = max(val - hKnee, 0.0);
        float3 hComp = hKnee + hExcess / (1.0 + hExcess * hStr);
        val = lerp(val, hComp, step(hKnee, val) * step(0.001, hStr));

        // Shadow compression
        float3 sDeficit = max(sKnee - val, 0.0);
        float3 sComp = sKnee - sDeficit / (1.0 + sDeficit * sStr);
        val = lerp(val, sComp, step(val, sKnee) * step(0.001, sStr));

        return val;
    }

    // ========================================================================
    // LOG GRADING (ACEScct - Colorist Workflow)
    // ========================================================================

    float3 ApplyGradingLog(float3 linearAP1)
    {
        // Convert to ACEScct log space
        float3 cc = LinearToACEScct(linearAP1);

        // Exposure: additive in log = stops
        cc += Exposure / 17.52;

        // White Balance: additive offsets (perceptually uniform)
        cc.r += Temperature * 0.03;
        cc.b -= Temperature * 0.03;
        cc.g += Tint * 0.02;

        // Contrast: pivot around mid-gray (0.4135884)
        cc = (cc - ACESCCT_MIDGRAY) * Contrast + ACESCCT_MIDGRAY;

        // Lift/Gamma/Gain (ASC-CDL style in log)
        cc += Lift * 0.1;
        cc *= Gain;
        float3 norm = saturate((cc - ACESCC_MIN) / ACESCC_RANGE);
        norm = pow(max(norm, 0.0001), 1.0 / max(Gamma, 0.01));
        cc = norm * ACESCC_RANGE + ACESCC_MIN;

        // Color Wheels
        float luma = (cc.r + cc.g + cc.b) / 3.0;
        float normLuma = saturate((luma - ACESCC_MIN) / ACESCC_RANGE);
        float3 weights = GetZoneWeights(normLuma);
        cc += ShadowColor * weights.x * 0.1;
        cc += MidtoneColor * weights.y * 0.1;
        cc += HighlightColor * weights.z * 0.1;

        // Highlights/Shadows: zone-weighted tonal adjustment (additive in log)
        cc += Shadows * weights.x * 0.15;
        cc += Highlights * weights.z * 0.15;

        // Post-grade offset
        cc += Offset * 0.1;

        // Saturation (via linear for accuracy)
        float3 lin = ACEScctToLinear(cc);
        float lumaLin = dot(lin, AP1_LUMA);
        float3 lumaCC = LinearToACEScct(float3(lumaLin, lumaLin, lumaLin));
        cc = lerp(lumaCC, cc, Saturation);

        // Vibrance: boost under-saturated, protect already-saturated
        if (abs(Vibrance) > 0.001)
        {
            float3 linV = ACEScctToLinear(cc);
            float lumaV = dot(linV, AP1_LUMA);
            float maxChan = max(linV.r, max(linV.g, linV.b));
            float satEst = saturate((maxChan - lumaV) / max(lumaV, 0.001));
            float vibAmt = Vibrance * (1.0 - satEst);
            float3 lumaVCC = LinearToACEScct(float3(lumaV, lumaV, lumaV));
            cc = lerp(lumaVCC, cc, 1.0 + vibAmt);
        }

        // Soft clip
        cc = ApplySoftClip(cc, HighlightKnee, HighlightSoftClip, ShadowKnee, ShadowSoftClip);

        // Convert back to linear AP1
        return ACEScctToLinear(cc);
    }

    // ========================================================================
    // LINEAR GRADING (ACEScg - VFX Workflow)
    // ========================================================================

    float3 ApplyGradingLinear(float3 lin)
    {
        // Exposure: multiplicative (camera-like)
        lin *= pow(2.0, Exposure);

        // White Balance: multiplicative gains (physically correct)
        lin.r *= 1.0 + Temperature * 0.1;
        lin.b *= 1.0 - Temperature * 0.1;
        lin.g *= 1.0 + Tint * 0.05;

        // Gain then Offset (Nuke order)
        lin *= Gain;
        lin += Offset * 0.1;

        // Gamma: power function
        lin = pow(max(lin, 0.0), 1.0 / max(Gamma, 0.01));

        // Contrast: power curve around 18% gray
        lin = LINEAR_MIDGRAY * pow(max(lin / LINEAR_MIDGRAY, 0.0001), Contrast);

        // Color Wheels (based on linear luminance)
        float luma = dot(lin, AP1_LUMA);
        float normLuma = saturate(luma / 2.0);  // Normalize for HDR
        float3 weights = GetZoneWeights(normLuma);
        lin += ShadowColor * weights.x * 0.1;
        lin += MidtoneColor * weights.y * 0.1;
        lin += HighlightColor * weights.z * 0.1;

        // Highlights/Shadows: zone-weighted tonal adjustment (multiplicative in linear)
        lin *= 1.0 + Shadows * weights.x * 0.5;
        lin *= 1.0 + Highlights * weights.z * 0.5;

        // Lift: additive shadow adjustment
        lin += Lift * 0.1;

        // Saturation (in linear - most accurate)
        lin = lerp(float3(luma, luma, luma), lin, Saturation);

        // Vibrance: boost under-saturated, protect already-saturated
        if (abs(Vibrance) > 0.001)
        {
            float lumaV = dot(lin, AP1_LUMA);
            float maxChan = max(lin.r, max(lin.g, lin.b));
            float satEst = saturate((maxChan - lumaV) / max(lumaV, 0.001));
            float vibAmt = Vibrance * (1.0 - satEst);
            lin = lerp(float3(lumaV, lumaV, lumaV), lin, 1.0 + vibAmt);
        }

        // Soft clip (scaled for linear space)
        lin = ApplySoftClip(lin, HighlightKnee * 2.0, HighlightSoftClip,
                           ShadowKnee * 0.1, ShadowSoftClip);

        return lin;
    }

    // ========================================================================
    // INPUT DECODING
    // ========================================================================

    // Decode any HDRColorSpace to Linear AP1 (the grading hub)
    // Direct paths for AP1 variants, hub through Linear709 for everything else
    float3 DecodeInput(float3 color)
    {
        if (InputSpace == 2)       // ACEScg - already AP1 linear
            return color;
        else if (InputSpace == 3)  // ACEScc - log AP1
            return ACESccToLinear(color);
        else if (InputSpace == 4)  // ACEScct - log AP1
            return ACEScctToLinear(color);
        else                       // All others → Linear709 → AP1
            return mul(Rec709_to_AP1, ToLinearRec709(color, InputSpace));
    }
};
