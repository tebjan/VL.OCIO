using System.Collections.Immutable;
using VL.Core;

namespace VL.OCIO;

/// <summary>
/// Represents a single color grading instance that can be controlled via the web UI.
/// Multiple instances can be registered with a ColorGradingServer, each with independent settings.
///
/// State persistence is hybrid:
/// - Editor mode: Server uses SetPinValue to update Create pin defaults (undo, presets, document save work)
/// - Exported mode: Server uses JSON files, instance uses runtime state override
/// </summary>
[ProcessNode]
public class ColorGradingInstance : IDisposable
{
    private readonly NodeContext _nodeContext;
    private readonly string _autoGeneratedId;
    private readonly bool _isExported;
    private ColorGradingServer? _registeredServer;
    private string _lastCustomId = "";

    // Runtime state overrides (used in exported mode to override Create pin defaults)
    private ColorCorrectionSettings? _runtimeColorCorrection;
    private TonemapSettings? _runtimeTonemap;
    private string? _runtimeInputFilePath;
    private bool _hasRuntimeState;

    public ColorGradingInstance(NodeContext nodeContext)
    {
        _nodeContext = nodeContext;
        _isExported = nodeContext.AppHost.IsExported;
        _autoGeneratedId = GenerateIdFromPath(nodeContext.Path.Stack);

        Console.WriteLine($"[ColorGradingInstance] Created instance '{_autoGeneratedId}' (exported: {_isExported})");
    }

    /// <summary>
    /// Main update method called every frame by VVVV.
    /// Create pins provide default values that can be overridden by the web UI.
    /// </summary>
    /// <param name="server">The ColorGradingServer to register with (optional)</param>
    /// <param name="customInstanceId">Custom instance ID (empty = auto-generated from node path)</param>
    /// <param name="colorCorrection">Create pin: default color correction settings</param>
    /// <param name="tonemap">Create pin: default tonemap settings</param>
    /// <param name="inputFilePath">Create pin: default input file path</param>
    /// <param name="outColorCorrection">Output: effective color correction (runtime override or Create pin default)</param>
    /// <param name="outTonemap">Output: effective tonemap (runtime override or Create pin default)</param>
    /// <param name="outInputFilePath">Output: effective input file path (runtime override or Create pin default)</param>
    /// <param name="effectiveInstanceId">Output: the actual instance ID being used</param>
    /// <param name="isRegistered">Output: true if currently registered with a server</param>
    public void Update(
        ColorGradingServer? server,
        string customInstanceId,
        ColorCorrectionSettings colorCorrection,
        TonemapSettings tonemap,
        string inputFilePath,
        out ColorCorrectionSettings outColorCorrection,
        out TonemapSettings outTonemap,
        out string outInputFilePath,
        out string effectiveInstanceId,
        out bool isRegistered)
    {
        // Determine effective instance ID
        effectiveInstanceId = string.IsNullOrWhiteSpace(customInstanceId)
            ? _autoGeneratedId
            : customInstanceId.Trim();

        // Handle server registration changes
        bool serverChanged = server != _registeredServer;
        bool idChanged = effectiveInstanceId != _lastCustomId;

        if (serverChanged || idChanged)
        {
            // Unregister from old server
            if (_registeredServer != null && !string.IsNullOrEmpty(_lastCustomId))
            {
                _registeredServer.UnregisterInstance(_lastCustomId);
            }

            // Register with new server
            if (server != null)
            {
                server.RegisterInstance(
                    effectiveInstanceId,
                    _nodeContext.Path.Stack,
                    _isExported,
                    this,
                    colorCorrection,
                    tonemap,
                    inputFilePath);
            }

            _registeredServer = server;
            _lastCustomId = effectiveInstanceId;
        }
        else if (server != null)
        {
            // Update the registered state if Create pin values changed
            server.UpdateInstanceDefaults(effectiveInstanceId, colorCorrection, tonemap, inputFilePath);
        }

        // Determine output values: runtime override (if set) or Create pin defaults
        if (_hasRuntimeState && _isExported)
        {
            // Exported mode: use runtime state if available
            outColorCorrection = _runtimeColorCorrection ?? colorCorrection;
            outTonemap = _runtimeTonemap ?? tonemap;
            outInputFilePath = _runtimeInputFilePath ?? inputFilePath;
        }
        else
        {
            // Editor mode: Create pins are the source of truth (SetPinValue updates them)
            outColorCorrection = colorCorrection;
            outTonemap = tonemap;
            outInputFilePath = inputFilePath;
        }

        isRegistered = server != null;
    }

    /// <summary>
    /// Called by the server (in exported mode) to set runtime state that overrides Create pin defaults.
    /// </summary>
    public void SetRuntimeState(
        ColorCorrectionSettings? colorCorrection,
        TonemapSettings? tonemap,
        string? inputFilePath)
    {
        _runtimeColorCorrection = colorCorrection;
        _runtimeTonemap = tonemap;
        _runtimeInputFilePath = inputFilePath;
        _hasRuntimeState = colorCorrection != null || tonemap != null || inputFilePath != null;
    }

    /// <summary>
    /// Clear runtime state, reverting to Create pin defaults.
    /// </summary>
    public void ClearRuntimeState()
    {
        _runtimeColorCorrection = null;
        _runtimeTonemap = null;
        _runtimeInputFilePath = null;
        _hasRuntimeState = false;
    }

    /// <summary>
    /// Get the node stack for SetPinValue operations (editor mode).
    /// </summary>
    public ImmutableStack<UniqueId> GetNodeStack() => _nodeContext.Path.Stack;

    /// <summary>
    /// Whether this instance is running in exported (standalone) mode.
    /// </summary>
    public bool IsExported => _isExported;

    /// <summary>
    /// Generate a human-readable instance ID from the node path.
    /// Uses the last meaningful part of the path stack.
    /// </summary>
    private static string GenerateIdFromPath(ImmutableStack<UniqueId> stack)
    {
        // Try to get a meaningful name from the stack
        foreach (var uniqueId in stack)
        {
            if (uniqueId.IsDefault)
                continue;

            var idStr = uniqueId.ToString();

            // Extract the last meaningful segment
            var parts = idStr.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length > 0)
            {
                var lastPart = parts[^1];
                // Remove any numeric suffix or hash
                var cleanName = System.Text.RegularExpressions.Regex.Replace(lastPart, @"_\d+$", "");
                if (!string.IsNullOrWhiteSpace(cleanName))
                {
                    return cleanName;
                }
            }
        }

        // Fallback to generic name with hash
        return $"Instance_{stack.GetHashCode():X8}";
    }

    public void Dispose()
    {
        // Unregister from server on dispose
        if (_registeredServer != null && !string.IsNullOrEmpty(_lastCustomId))
        {
            _registeredServer.UnregisterInstance(_lastCustomId);
            _registeredServer = null;
        }

        Console.WriteLine($"[ColorGradingInstance] Disposed instance '{_autoGeneratedId}'");
    }
}
