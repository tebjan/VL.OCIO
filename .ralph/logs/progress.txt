### Iteration 1 — 2026-02-21 — 1.1: Initialize Vite + React 19 + TypeScript + Tailwind 4 project
- Implemented: Created pipeline-checker/ with package.json (React 19, Three.js, Vite 6, Tailwind 4, vite-plugin-singlefile), vite.config.ts (base ./, asset inlining, single-file build), tsconfig.json + tsconfig.node.json, index.html with dark BG flash prevention, src/index.css (Tailwind v4 @import + dark theme CSS vars), src/main.tsx, src/App.tsx (minimal placeholder), type declarations for .wgsl?raw and .exr imports, and webgpu.d.ts reference.
- Files changed: pipeline-checker/package.json, vite.config.ts, tsconfig.json, tsconfig.node.json, index.html, src/index.css, src/main.tsx, src/App.tsx, src/types/raw-imports.d.ts, src/types/webgpu.d.ts
- Learnings: Tailwind v4 uses @tailwindcss/vite plugin instead of postcss.config.js. No tailwind.config.js needed. App.tsx is a minimal placeholder — WebGPUContext and DropZone are separate tasks (1.2, 1.3).
- Validation: npm install (0 vulnerabilities), npx tsc --noEmit (clean), npm run build (200 KB single HTML)

### Iteration 2 — 2026-02-21 — 1.2: WebGPU device initialization
- Implemented: Created src/gpu/WebGPUContext.ts with GPUContext interface (adapter, device, format, canvasContext, hasBC), initWebGPU() async function that requests high-performance adapter, conditionally enables texture-compression-bc, sets 256MB storage/buffer limits, configures canvas with premultiplied alpha, and handles device.lost.
- Files changed: pipeline-checker/src/gpu/WebGPUContext.ts
- Learnings: Extended GPUContext interface beyond spec template to include canvasContext and hasBC flag for downstream use. device.lost handler logs but doesn't auto-recover yet.
- Validation: npx tsc --noEmit (clean), npm run build (201 KB single HTML)

### Iteration 3 — 2026-02-21 — 1.3: EXR drop zone component + Try sample button
- Implemented: Created DropZone.tsx with drag-drop EXR support (Three.js EXRLoader, half-float conversion), procedural HDR sample generator (256x256 hue/brightness gradient), drag counter pattern for flicker prevention. Created WebGPUCanvas.tsx (hidden 1x1 canvas for WebGPU context). Updated App.tsx with state machine (initializing/error/ready/loaded), WebGPU init on mount, DropZone integration.
- Files changed: pipeline-checker/src/components/DropZone.tsx (new), pipeline-checker/src/components/WebGPUCanvas.tsx (new), pipeline-checker/src/App.tsx (rewritten)
- Learnings: Used procedural sample generation instead of importing a .exr asset file — avoids build dependency on a binary asset. Task 1.5 in phase file was merged into 1.3 in fix_plan.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML)

### Iteration 4 — 2026-02-21 — 1.4: Dark theme setup
- Implemented: Verified dark theme was already complete from iteration 1. All CSS custom properties match spec exactly: --color-bg #0d0d0d, --color-surface #1a1a1a, --color-border #2a2a2a, --color-text #e0e0e0, --color-text-muted #808080, --color-accent #4a4a4a, --color-accent-hover #5a5a5a, --color-error #cc4444. No saturated accent colors anywhere. White-flash prevention inline style in index.html. Scrollbar theming.
- Files changed: None (theme was already correct; only checkboxes updated)
- Learnings: Task 1.4 was effectively completed during 1.1 when index.css was created. All components already use CSS vars, no hardcoded saturated colors.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML), grep confirmed no saturated color literals in src/

### Iteration 5 — 2026-02-21 — 1.5: Phase 1 final verification
- Implemented: Ran all three verification commands. npm install (0 vulnerabilities, 98 packages), npx tsc --noEmit (clean), npm run build (296 KB single HTML). Phase 1 is fully complete.
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 1 complete. Wave 1 done. Next is Wave 2: Phase 3 (WebGPU Render Pipeline) or Phase 5 (BC Encoder). Phase 3 should come first since Phase 4 depends on it.
- Validation: npm install (clean), npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 6 — 2026-02-21 — 3.1: PipelineStage interface
- Implemented: Created src/pipeline/PipelineStage.ts with the PipelineStage interface — name, index, enabled, output properties + initialize/resize/encode/destroy lifecycle methods. encode() takes GPUCommandEncoder, GPUTexture (input), GPUBuffer (uniforms).
- Files changed: pipeline-checker/src/pipeline/PipelineStage.ts (new)
- Learnings: Section file clarifies encode() takes GPUBuffer (not PipelineSettings type), keeping the interface dependency-free. PipelineSettings type comes in task 3.5.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 7 — 2026-02-21 — 3.2: FragmentStage implementation
- Implemented: Created src/pipeline/FragmentStage.ts implementing PipelineStage. Includes embedded fullscreen triangle vertex shader (no external file), bind group layout (unfilterable-float texture + non-filtering sampler + uniform buffer), GPURenderPipeline creation with rgba32float target (blend: undefined), encode() with per-frame bind group, render target with RENDER_ATTACHMENT | TEXTURE_BINDING | COPY_SRC. Constructor takes (name, index, fragmentWGSL) — vertex shader is prepended automatically.
- Files changed: pipeline-checker/src/pipeline/FragmentStage.ts (new)
- Learnings: tsconfig has noUnusedLocals — removed width/height private fields that were stored but never read. The vertex shader is embedded as a string constant per section-03 spec ("embedded as a constant string in FragmentStage.ts"). The fullscreen-quad.wgsl file (task 4.7) can refactor this later if needed.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 8 — 2026-02-21 — 3.3: PipelineRenderer orchestrator
- Implemented: Created src/pipeline/PipelineRenderer.ts — stage orchestrator with: constructor creates 512-byte uniform buffer, setStages() registers stages, setSize() initializes (first call) or resizes (subsequent) all stages, render() chains enabled stages in single command buffer (disabled stages bypass transparently), getStageOutput() walks backwards to find last enabled stage, updateUniforms() writes raw Float32Array to GPU buffer, destroy() cleans up all resources.
- Files changed: pipeline-checker/src/pipeline/PipelineRenderer.ts (new)
- Learnings: WebGPU TypeScript types require Float32Array<ArrayBuffer> (not Float32Array<ArrayBufferLike>) for writeBuffer compatibility. Fixed spec's setSize bug where this.width was set before the initialization check. The PipelineSettings typed interface comes in 3.5 — for now updateUniforms takes raw Float32Array.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 9 — 2026-02-21 — 3.4: Render target management
- Implemented: Created src/pipeline/TextureUtils.ts with shared utilities: BYTES_PER_PIXEL (16) and ROW_ALIGNMENT (256) constants, alignedBytesPerRow() for 256-byte readback alignment, copyAlignedToContiguous() for stripping row padding from mapped buffers, uploadFloat32Texture() for writing Float32Array RGBA data to GPUTexture (TEXTURE_BINDING | COPY_SRC | COPY_DST). Render target creation itself was already in FragmentStage (RENDER_ATTACHMENT | TEXTURE_BINDING | COPY_SRC).
- Files changed: pipeline-checker/src/pipeline/TextureUtils.ts (new)
- Learnings: writeTexture (upload) does NOT require 256-byte bytesPerRow alignment — only copyTextureToBuffer (readback) does. Upload uses width*16 directly. The upload texture needs COPY_DST (for upload) while stage render targets don't (they write via render passes).
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 10 — 2026-02-21 — 3.5: PipelineUniforms
- Implemented: Created src/pipeline/PipelineUniforms.ts with: PipelineSettings interface (all 30+ fields covering stages 4-9 + toggles + BC + view), DEFAULT_SETTINGS constant (neutral grading, no tonemap, passthrough), serializeUniforms() that writes to a shared Float32Array/Int32Array (512 bytes). Layout matches WGSL struct with vec3+pad pattern: 10 scalars, 2-float pad, 7x vec3+pad blocks, 4 more scalars, 6 tonemap fields, 2 remap fields, 3 toggle i32s, 2 BC i32s, 1 view float. Total ~232 bytes used of 512.
- Files changed: pipeline-checker/src/pipeline/PipelineUniforms.ts (new)
- Learnings: serializeUniforms returns Float32Array<ArrayBuffer> (matching PipelineRenderer.updateUniforms signature). The _pad0 at offset 40 is vec2<f32> (8 bytes) to align the first vec3 (lift) to 16-byte boundary at offset 48. All subsequent vec3s naturally align because each is 12+4=16 bytes.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 11 — 2026-02-21 — 3.6: PixelReadback utility
- Implemented: Created src/pipeline/PixelReadback.ts with async readPixel(texture, x, y) method. Uses pending flag for debounce (returns null if previous read in-flight). Creates 256-byte staging buffer per read (minimum for bytesPerRow alignment), copyTextureToBuffer for single pixel, mapAsync + getMappedRange to extract [R,G,B,A] Float32Array(4). Buffer destroyed after each read.
- Files changed: pipeline-checker/src/pipeline/PixelReadback.ts (new)
- Learnings: Even single-pixel readback requires 256-byte bytesPerRow alignment. Throttling to 30Hz is handled by the caller (Phase 8 UI), not by this class. try/finally ensures pending flag is always reset even on error.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 12 — 2026-02-21 — 3.7: Phase 3 final verification
- Implemented: Ran full verification suite. All 6 pipeline files present: PipelineStage.ts, FragmentStage.ts, PipelineRenderer.ts, TextureUtils.ts, PipelineUniforms.ts, PixelReadback.ts. npm install (0 vulnerabilities), npx tsc --noEmit (clean), npm run build (296 KB single HTML). Phase 3 is fully complete.
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 3 complete. Wave 2 Phase 3 done. Next is either Phase 5 (BC Encoder Package) or skip to Wave 3 Phase 4 (Color Pipeline WGSL Shaders) — but Phase 4 requires Phase 3 which is now done. Phase 5 (BC) is optional per dependency rules. Follow fix_plan.md order: Phase 5 next.
- Validation: npm install (clean), npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 13 — 2026-02-21 — 5.1: BC encoder package scaffolding
- Implemented: Created packages/webgpu-bc-encoder/ with package.json, tsconfig.json, and all source files: index.ts (types + constants), encoder.ts (BCEncoder placeholder), metrics.ts (BCMetricsComputer placeholder), formats/handler.ts (BCFormatHandler interface), 7 format handler files (bc1-bc7.ts), 8 WGSL compute shader placeholders, wgsl.d.ts type declaration.
- Files changed: 24 files in packages/webgpu-bc-encoder/
- Learnings: Package needs its own wgsl.d.ts for ?raw import type resolution. Format handlers use placeholder throw for task 5.2 implementation.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 14 — 2026-02-21 — 5.2 + 5.3: Port WGSL compute shaders + BCEncoder class
- Implemented: Wrote all 7 BC format WGSL compute shaders with real encoding algorithms:
  - BC1: bounding box min/max endpoints, RGB565 packing, 4-color palette, 2-bit indices
  - BC4: min/max single channel, u8 endpoints, 8-value interpolation, 3-bit indices
  - BC2: BC1 color + 4-bit explicit alpha per pixel
  - BC3: BC1 color + BC4-style interpolated alpha
  - BC5: Two independent BC4 blocks (R + G channels)
  - BC6H: Mode 11 (unsigned, no partitioning, 10-bit endpoints, 4-bit indices, pack2x16float)
  - BC7: Mode 6 (no partitioning, RGBA 7+1 bit endpoints, 4-bit indices)
  Updated all format handlers to import WGSL via ?raw and create real GPUComputePipeline.
  Rewrote encoder.ts with full pipeline: getPipeline cache, uniform buffer, storage buffer, bind group, dispatch, staging readback.
  Added BCFormatHandler.supportsAlpha + alphaWarning fields. BC6H has alphaWarning string.
  Added static BCEncoder.getHandler() for downstream alpha warning access.
- Files changed: 7 WGSL shaders, 8 format .ts files (handler + bc1-bc7), encoder.ts, index.ts, wgsl.d.ts
- Learnings: block_compression repo not accessible (404). Implemented from BC spec knowledge. BC6H Mode 11 uses pack2x16float for float-to-half conversion. Anchor index fix: if anchor pixel >= half, flip all indices. All shaders share common bind group layout (binding 0=texture, 1=storage, 2=uniform). Task 5.3 was naturally completed alongside 5.2 since the encoder needed the pipelines.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 15 — 2026-02-21 — 5.4: BC metrics compute shader
- Implemented: Wrote bc-metrics.wgsl compute shader (8x8 workgroups) that computes per-pixel squared error and absolute error (6 floats per pixel: SE_R, SE_G, SE_B, AE_R, AE_G, AE_B). Implemented BCMetricsComputer class in metrics.ts with: lazy pipeline creation, GPU dispatch, staging buffer readback, CPU-side reduction (sum SE → MSE, max AE → max error), PSNR computation (10*log10(1/MSE)). Added mseCombined field to BCMetrics interface in index.ts.
- Files changed: packages/webgpu-bc-encoder/src/shaders/bc-metrics.wgsl, packages/webgpu-bc-encoder/src/metrics.ts, packages/webgpu-bc-encoder/src/index.ts
- Learnings: Uniform buffer for metrics params only needs 8 bytes (2 x u32). Error buffer is width*height*6*4 bytes — can be large for high-res images. CPU reduction is simple enough that GPU reduction isn't needed for interactive use.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 16 — 2026-02-21 — 5.5: Phase 5 verification
- Implemented: Verification pass — no code changes needed. Confirmed: tsc --noEmit clean, npm run build clean (296 KB), all 8 WGSL shaders present (7 encode + 1 metrics), all 7 format handlers + handler interface present, all exports correct (BCEncoder, BCMetricsComputer, BCFormatHandler, BCFormat, BCQuality, BCEncodeResult, BCMetrics, BC_BLOCK_SIZE, BC_FORMAT_TO_GPU), all shader imports use ?raw (no fetch), BC6H alpha warning correctly configured (supportsAlpha: false, alphaWarning populated).
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 5 complete. Wave 2 fully done. Next is Wave 3: Phase 4 (Color Pipeline WGSL Shaders) — requires reading phase-04-color-shaders.md and its section file for tonemap algorithm constants.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 17 — 2026-02-21 — 4.1: input-convert.wgsl (Stage 4 — Input Interpretation)
- Implemented: Created src/shaders/generated/input-convert.wgsl with complete color space conversion library. All 6 gamut matrices transposed for WGSL column-major (Rec709↔Rec2020, Rec709↔AP1, Rec2020↔AP1). All 10 transfer functions (sRGB IEC 61966-2-1 piecewise, ACEScc branchless log2, ACEScct branchless with step(), PQ ST.2084, HLG ARIB STD-B67 branchless). ToLinearRec709() + FromLinearRec709() + ConvertColorSpace() hub functions. Fragment shader reads inputSpace uniform (i32 at offset 0) and converts input to Linear Rec.709. Vertex shader is prepended by FragmentStage — shader only declares bindings 0/1/2 and fs entrypoint.
- Files changed: pipeline-checker/src/shaders/generated/input-convert.wgsl (new)
- Learnings: FragmentStage prepends VertexOutput struct + vs entrypoint. Fragment shader must NOT redeclare these. Uniform struct can be minimal — only declare fields this stage reads (inputSpace at offset 0). WGSL step() takes vec3 args when operating on vec3 (e.g., step(vec3<f32>(0.5), V) not step(0.5, V)).
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 18 — 2026-02-21 — 4.2: color-grade.wgsl (Stage 5 — Color Grading)
- Implemented: Created src/shaders/generated/color-grade.wgsl with full professional color grading. Uniform struct covers PipelineUniforms offsets 0-172 (22 params: inputSpace, gradingSpace, exposure, contrast, saturation, temperature, tint, highlights, shadows, vibrance, lift/gamma/gain/offset vec3, shadowColor/midtoneColor/highlightColor vec3, highlightSoftClip/shadowSoftClip/highlightKnee/shadowKnee). WGSL vec3 alignment causes implicit 8-byte padding between vibrance (offset 36) and lift (offset 48) — matches PipelineUniforms.ts layout. Includes DecodeInput() (any space → Linear AP1 via hub), ApplyGradingLog() (12-step ACEScct workflow), ApplyGradingLinear() (11-step ACEScg workflow), GetZoneWeights(), ApplySoftClip(). Output converts back via AP1_to_Rec709.
- Files changed: pipeline-checker/src/shaders/generated/color-grade.wgsl (new)
- Learnings: WGSL `step(scalar, vec3)` doesn't auto-broadcast — use `step(vec3<f32>(scalar), vec3)` for vec3 comparisons. In ApplySoftClip, the `step(0.001, hStr)` is scalar×scalar producing scalar, which then multiplies vec3 — this works in WGSL. The `offset` WGSL keyword issue was avoided by naming the field `offset_val`. WGSL pow() requires vec3 args for vec3 results: `pow(vec3, vec3<f32>(scalar))`.
- Validation: npx tsc --noEmit (clean), npm run build (298 KB)

### Iteration 19 — 2026-02-21 — 4.8: Wire all stages into PipelineRenderer
- Implemented: Created 6 stage wrapper files in src/pipeline/stages/ (InputConvertStage.ts, ColorGradeStage.ts, RRTStage.ts, ODTStage.ts, OutputEncodeStage.ts, DisplayRemapStage.ts). Each is a factory function that imports the WGSL shader via ?raw and returns a FragmentStage instance. Created index.ts barrel with createColorPipelineStages() that returns all 6 stages in order (Stages 4-9). Also includes 4.6 (display-remap.wgsl) and 4.7 (fullscreen-vert.wgsl extraction from FragmentStage.ts inline to ?raw import).
- Files changed: pipeline-checker/src/pipeline/stages/{InputConvertStage,ColorGradeStage,RRTStage,ODTStage,OutputEncodeStage,DisplayRemapStage,index}.ts (new), pipeline-checker/src/shaders/generated/{display-remap,fullscreen-vert}.wgsl (new), pipeline-checker/src/pipeline/FragmentStage.ts (refactored inline vertex to ?raw import)
- Learnings: Stage files are tree-shaken until a consumer (usePipeline hook or App) imports createColorPipelineStages(). The 38-module count stays stable because Vite only includes reachable modules.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 20 — 2026-02-21 — 4.9: Phase 4 verification gate
- Implemented: Verified all Phase 4 deliverables. tsc --noEmit clean, npm run build 297.86 KB. All 7 WGSL files present (6 fragment shaders + 1 vertex shader). All 6 fragment shaders have @fragment fn fs entry point and @group(0) @binding(2) uniform binding. fullscreen-vert.wgsl has @vertex fn vs. 6 stage factory files create correct stage indices (4-9) with descriptive names. Barrel index.ts creates stages in correct pipeline order. FragmentStage.ts imports fullscreen-vert.wgsl via ?raw (no inline duplication). Phase 4 complete.
- Files changed: .ralph/fix_plan.md, .ralph/specs/phase-04-color-shaders.md (checkboxes only)
- Learnings: Visual EXR test requires browser+WebGPU — deferred to manual testing. All static verification passes. Phase 4 is the completion gate for all 6 color pipeline shaders.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB), all WGSL files verified

### Iteration 21 — 2026-02-21 — 6.1: BCCompressStage compute stage
- Implemented: Created src/pipeline/stages/BCCompressStage.ts implementing PipelineStage interface. Compute stage (not fragment) that wraps the @vl-ocio/webgpu-bc-encoder BCEncoder. Sync encode() passes through input as output (BC data not displayable). Async runEncode() dispatches the encoder and caches results by format+quality+dimensions key. Supports format/quality setters, cache invalidation, and guards against duplicate concurrent encodes. Added tsconfig.json paths mapping and Vite resolve.alias for @vl-ocio/webgpu-bc-encoder package, plus included packages/webgpu-bc-encoder/src in tsconfig include array.
- Files changed: pipeline-checker/src/pipeline/stages/BCCompressStage.ts (new), pipeline-checker/tsconfig.json (paths + include), pipeline-checker/vite.config.ts (resolve.alias)
- Learnings: The BC encoder package wasn't wired as a dependency — needed tsconfig paths + Vite alias for both tsc and bundler resolution. BCEncoder creates its own command encoder internally (not using the shared one), so BCCompressStage.encode() doesn't record GPU commands. The PipelineStage interface is synchronous, so async encoding happens via a separate runEncode() method called before the render loop. noUnusedParameters catches stored-but-never-read private fields.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 22 — 2026-02-21 — 6.2: BCDecompressStage hardware decode
- Implemented: Created src/pipeline/shaders/bc-decompress.wgsl (fullscreen triangle that samples from native BC compressed texture — GPU hardware auto-decompresses). Created src/pipeline/stages/BCDecompressStage.ts implementing PipelineStage: initialize creates linear sampler + rgba32float render target + auto-layout render pipeline; uploadBCData() creates native BC compressed texture via BC_FORMAT_TO_GPU mapping and writeTexture; encode() records fullscreen render pass sampling from BC texture; falls back to passthrough when no BC data available.
- Files changed: pipeline-checker/src/pipeline/shaders/bc-decompress.wgsl (new), pipeline-checker/src/pipeline/stages/BCDecompressStage.ts (new)
- Learnings: Uint8Array from BCEncodeResult.data needs explicit cast to Uint8Array<ArrayBuffer> for writeTexture's GPUAllowSharedBufferSource param (TypeScript strict mode with SharedArrayBuffer). BC decompress uses layout:'auto' since bind group is simple (texture + sampler only). The WGSL shader includes its own VertexOutput struct and vertex shader (not using shared fullscreen-vert.wgsl) since BC decompress uses a filtering sampler, unlike the color stages which use non-filtering.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 23 — 2026-02-21 — 6.3: BC metrics display data infrastructure
- Implemented: Created src/pipeline/types/BCMetrics.ts with PipelineBCMetrics interface (nested ChannelMetrics objects for psnr/maxError/mse, plus encode metadata: compressionRatio, encodedSizeBytes, encodeTimeMs, format, dimensions). Created src/pipeline/utils/computeBCMetrics.ts — async function wrapping encoder's BCMetricsComputer, maps flat BCMetrics fields to nested structure, computes compression ratio (uncompressed rgba32float vs encoded). The actual UI rendering of metrics in stage cards is Phase 7 (StageCard component).
- Files changed: pipeline-checker/src/pipeline/types/BCMetrics.ts (new), pipeline-checker/src/pipeline/utils/computeBCMetrics.ts (new)
- Learnings: BCMetricsComputer already has device internally, so computeBCMetrics doesn't need a device param. The encoder's BCMetrics uses flat naming (psnrR, mseG) while the pipeline's PipelineBCMetrics uses nested objects (psnr.r, mse.g) — the utility bridges the two.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 24 — 2026-02-21 — 6.4: Delta overlay WGSL shader
- Implemented: Created src/pipeline/shaders/bc-delta.wgsl — fragment shader computing abs(original - decompressed) * amplification for BC compression artifact visualization. Binds two texture_2d<f32> inputs (original + decompressed), a sampler, and a DeltaParams uniform with amplification factor (16-byte aligned). Default amplification 10.0. Alpha forced to 1.0. Fullscreen triangle vertex shader included. UI toggle/slider wiring deferred to Phase 7.
- Files changed: pipeline-checker/src/pipeline/shaders/bc-delta.wgsl (new)
- Learnings: Delta shader needs two input textures bound simultaneously (originalTex and decompressedTex), unlike the single-input color stages. The DeltaParams struct is padded to 16 bytes (1 f32 + 3 padding). The delta pipeline in BCDecompressStage will need a separate render pipeline with auto layout since the bind group layout differs from the decompress path.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 25 — 2026-02-21 — 6.5: Graceful fallback when texture-compression-bc unavailable
- Implemented: Added optional `available?: boolean` property to PipelineStage interface (defaults true). BCCompressStage constructor now takes `(device, hasBC)` — when !hasBC, encoder is null, stage auto-disabled. BCDecompressStage constructor now takes `(hasBC)` — when !hasBC, initialize/resize/uploadBCData all early-return. Pipeline passes EXR directly to Stage 4.
- Files changed: PipelineStage.ts, BCCompressStage.ts, BCDecompressStage.ts
- Learnings: Nullable encoder pattern (`BCEncoder | null`) with optional chaining (`this.encoder?.destroy()`) keeps the code clean. Early-return guards in initialize/resize/uploadBCData prevent any GPU resource creation when BC unavailable.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB)

### Iteration 26 — 2026-02-21 — 6.6: Phase 6 verification gate
- Implemented: Verification-only task. Confirmed all 6 Phase 6 files exist: BCCompressStage.ts, BCDecompressStage.ts, BCMetrics.ts, computeBCMetrics.ts, bc-decompress.wgsl, bc-delta.wgsl. Both stages implement PipelineStage with available/hasBC fallback. Build stable at 297.86 KB.
- Files changed: (checkboxes only)
- Learnings: Phase 6 is complete. All BC infrastructure is in place. UI wiring (format selector, delta toggle, metrics display, "Not Available" labels) will happen in Phase 7.
- Validation: npx tsc --noEmit (clean), npm run build (297.86 KB, gzip 93.98 KB)
