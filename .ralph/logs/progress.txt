### Iteration 1 — 2026-02-21 — 1.1: Initialize Vite + React 19 + TypeScript + Tailwind 4 project
- Implemented: Created pipeline-checker/ with package.json (React 19, Three.js, Vite 6, Tailwind 4, vite-plugin-singlefile), vite.config.ts (base ./, asset inlining, single-file build), tsconfig.json + tsconfig.node.json, index.html with dark BG flash prevention, src/index.css (Tailwind v4 @import + dark theme CSS vars), src/main.tsx, src/App.tsx (minimal placeholder), type declarations for .wgsl?raw and .exr imports, and webgpu.d.ts reference.
- Files changed: pipeline-checker/package.json, vite.config.ts, tsconfig.json, tsconfig.node.json, index.html, src/index.css, src/main.tsx, src/App.tsx, src/types/raw-imports.d.ts, src/types/webgpu.d.ts
- Learnings: Tailwind v4 uses @tailwindcss/vite plugin instead of postcss.config.js. No tailwind.config.js needed. App.tsx is a minimal placeholder — WebGPUContext and DropZone are separate tasks (1.2, 1.3).
- Validation: npm install (0 vulnerabilities), npx tsc --noEmit (clean), npm run build (200 KB single HTML)

### Iteration 2 — 2026-02-21 — 1.2: WebGPU device initialization
- Implemented: Created src/gpu/WebGPUContext.ts with GPUContext interface (adapter, device, format, canvasContext, hasBC), initWebGPU() async function that requests high-performance adapter, conditionally enables texture-compression-bc, sets 256MB storage/buffer limits, configures canvas with premultiplied alpha, and handles device.lost.
- Files changed: pipeline-checker/src/gpu/WebGPUContext.ts
- Learnings: Extended GPUContext interface beyond spec template to include canvasContext and hasBC flag for downstream use. device.lost handler logs but doesn't auto-recover yet.
- Validation: npx tsc --noEmit (clean), npm run build (201 KB single HTML)

### Iteration 3 — 2026-02-21 — 1.3: EXR drop zone component + Try sample button
- Implemented: Created DropZone.tsx with drag-drop EXR support (Three.js EXRLoader, half-float conversion), procedural HDR sample generator (256x256 hue/brightness gradient), drag counter pattern for flicker prevention. Created WebGPUCanvas.tsx (hidden 1x1 canvas for WebGPU context). Updated App.tsx with state machine (initializing/error/ready/loaded), WebGPU init on mount, DropZone integration.
- Files changed: pipeline-checker/src/components/DropZone.tsx (new), pipeline-checker/src/components/WebGPUCanvas.tsx (new), pipeline-checker/src/App.tsx (rewritten)
- Learnings: Used procedural sample generation instead of importing a .exr asset file — avoids build dependency on a binary asset. Task 1.5 in phase file was merged into 1.3 in fix_plan.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML)

### Iteration 4 — 2026-02-21 — 1.4: Dark theme setup
- Implemented: Verified dark theme was already complete from iteration 1. All CSS custom properties match spec exactly: --color-bg #0d0d0d, --color-surface #1a1a1a, --color-border #2a2a2a, --color-text #e0e0e0, --color-text-muted #808080, --color-accent #4a4a4a, --color-accent-hover #5a5a5a, --color-error #cc4444. No saturated accent colors anywhere. White-flash prevention inline style in index.html. Scrollbar theming.
- Files changed: None (theme was already correct; only checkboxes updated)
- Learnings: Task 1.4 was effectively completed during 1.1 when index.css was created. All components already use CSS vars, no hardcoded saturated colors.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB single HTML), grep confirmed no saturated color literals in src/

### Iteration 5 — 2026-02-21 — 1.5: Phase 1 final verification
- Implemented: Ran all three verification commands. npm install (0 vulnerabilities, 98 packages), npx tsc --noEmit (clean), npm run build (296 KB single HTML). Phase 1 is fully complete.
- Files changed: None (verification only; checkboxes updated)
- Learnings: Phase 1 complete. Wave 1 done. Next is Wave 2: Phase 3 (WebGPU Render Pipeline) or Phase 5 (BC Encoder). Phase 3 should come first since Phase 4 depends on it.
- Validation: npm install (clean), npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 6 — 2026-02-21 — 3.1: PipelineStage interface
- Implemented: Created src/pipeline/PipelineStage.ts with the PipelineStage interface — name, index, enabled, output properties + initialize/resize/encode/destroy lifecycle methods. encode() takes GPUCommandEncoder, GPUTexture (input), GPUBuffer (uniforms).
- Files changed: pipeline-checker/src/pipeline/PipelineStage.ts (new)
- Learnings: Section file clarifies encode() takes GPUBuffer (not PipelineSettings type), keeping the interface dependency-free. PipelineSettings type comes in task 3.5.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)

### Iteration 7 — 2026-02-21 — 3.2: FragmentStage implementation
- Implemented: Created src/pipeline/FragmentStage.ts implementing PipelineStage. Includes embedded fullscreen triangle vertex shader (no external file), bind group layout (unfilterable-float texture + non-filtering sampler + uniform buffer), GPURenderPipeline creation with rgba32float target (blend: undefined), encode() with per-frame bind group, render target with RENDER_ATTACHMENT | TEXTURE_BINDING | COPY_SRC. Constructor takes (name, index, fragmentWGSL) — vertex shader is prepended automatically.
- Files changed: pipeline-checker/src/pipeline/FragmentStage.ts (new)
- Learnings: tsconfig has noUnusedLocals — removed width/height private fields that were stored but never read. The vertex shader is embedded as a string constant per section-03 spec ("embedded as a constant string in FragmentStage.ts"). The fullscreen-quad.wgsl file (task 4.7) can refactor this later if needed.
- Validation: npx tsc --noEmit (clean), npm run build (296 KB)
